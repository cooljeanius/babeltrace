# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Babeltrace 1.2.2

Babeltrace  is a trace viewer and converter reading and writing the
Common Trace Format (CTF). Its main use is to pretty-print CTF
traces into a human-readable text output.

To use this module, the first step is to create a TraceCollection and add a
trace to it.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_babeltrace', [dirname(__file__)])
        except ImportError:
            import _babeltrace
            return _babeltrace
        if fp is not None:
            try:
                _mod = imp.load_module('_babeltrace', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _babeltrace = swig_import_helper()
    del swig_import_helper
else:
    import _babeltrace
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def _bt_python_field_listcaller(*args):
  return _babeltrace._bt_python_field_listcaller(*args)
_bt_python_field_listcaller = _babeltrace._bt_python_field_listcaller

def _bt_python_field_one_from_list(*args):
  return _babeltrace._bt_python_field_one_from_list(*args)
_bt_python_field_one_from_list = _babeltrace._bt_python_field_one_from_list

def _bt_python_event_decl_listcaller(*args):
  return _babeltrace._bt_python_event_decl_listcaller(*args)
_bt_python_event_decl_listcaller = _babeltrace._bt_python_event_decl_listcaller

def _bt_python_decl_one_from_list(*args):
  return _babeltrace._bt_python_decl_one_from_list(*args)
_bt_python_decl_one_from_list = _babeltrace._bt_python_decl_one_from_list

def _by_python_field_decl_listcaller(*args):
  return _babeltrace._by_python_field_decl_listcaller(*args)
_by_python_field_decl_listcaller = _babeltrace._by_python_field_decl_listcaller

def _bt_python_field_decl_one_from_list(*args):
  return _babeltrace._bt_python_field_decl_one_from_list(*args)
_bt_python_field_decl_one_from_list = _babeltrace._bt_python_field_decl_one_from_list

def _bt_python_get_array_from_def(*args):
  return _babeltrace._bt_python_get_array_from_def(*args)
_bt_python_get_array_from_def = _babeltrace._bt_python_get_array_from_def

def _bt_python_get_sequence_from_def(*args):
  return _babeltrace._bt_python_get_sequence_from_def(*args)
_bt_python_get_sequence_from_def = _babeltrace._bt_python_get_sequence_from_def

def _bt_python_get_array_element_declaration(*args):
  return _babeltrace._bt_python_get_array_element_declaration(*args)
_bt_python_get_array_element_declaration = _babeltrace._bt_python_get_array_element_declaration

def _bt_python_get_sequence_element_declaration(*args):
  return _babeltrace._bt_python_get_sequence_element_declaration(*args)
_bt_python_get_sequence_element_declaration = _babeltrace._bt_python_get_sequence_element_declaration

def _bt_python_get_array_string(*args):
  return _babeltrace._bt_python_get_array_string(*args)
_bt_python_get_array_string = _babeltrace._bt_python_get_array_string

def _bt_python_get_sequence_string(*args):
  return _babeltrace._bt_python_get_sequence_string(*args)
_bt_python_get_sequence_string = _babeltrace._bt_python_get_sequence_string

def _bt_python_field_integer_get_signedness(*args):
  return _babeltrace._bt_python_field_integer_get_signedness(*args)
_bt_python_field_integer_get_signedness = _babeltrace._bt_python_field_integer_get_signedness

def _bt_python_get_field_type(*args):
  return _babeltrace._bt_python_get_field_type(*args)
_bt_python_get_field_type = _babeltrace._bt_python_get_field_type

def _bt_python_ctf_field_type_enumeration_get_mapping(*args):
  return _babeltrace._bt_python_ctf_field_type_enumeration_get_mapping(*args)
_bt_python_ctf_field_type_enumeration_get_mapping = _babeltrace._bt_python_ctf_field_type_enumeration_get_mapping

def _bt_python_ctf_field_type_enumeration_get_mapping_unsigned(*args):
  return _babeltrace._bt_python_ctf_field_type_enumeration_get_mapping_unsigned(*args)
_bt_python_ctf_field_type_enumeration_get_mapping_unsigned = _babeltrace._bt_python_ctf_field_type_enumeration_get_mapping_unsigned

def _bt_python_ctf_field_type_structure_get_field_name(*args):
  return _babeltrace._bt_python_ctf_field_type_structure_get_field_name(*args)
_bt_python_ctf_field_type_structure_get_field_name = _babeltrace._bt_python_ctf_field_type_structure_get_field_name

def _bt_python_ctf_field_type_structure_get_field_type(*args):
  return _babeltrace._bt_python_ctf_field_type_structure_get_field_type(*args)
_bt_python_ctf_field_type_structure_get_field_type = _babeltrace._bt_python_ctf_field_type_structure_get_field_type

def _bt_python_ctf_field_type_variant_get_field_name(*args):
  return _babeltrace._bt_python_ctf_field_type_variant_get_field_name(*args)
_bt_python_ctf_field_type_variant_get_field_name = _babeltrace._bt_python_ctf_field_type_variant_get_field_name

def _bt_python_ctf_field_type_variant_get_field_type(*args):
  return _babeltrace._bt_python_ctf_field_type_variant_get_field_type(*args)
_bt_python_ctf_field_type_variant_get_field_type = _babeltrace._bt_python_ctf_field_type_variant_get_field_type

def _bt_python_ctf_event_class_get_field_name(*args):
  return _babeltrace._bt_python_ctf_event_class_get_field_name(*args)
_bt_python_ctf_event_class_get_field_name = _babeltrace._bt_python_ctf_event_class_get_field_name

def _bt_python_ctf_event_class_get_field_type(*args):
  return _babeltrace._bt_python_ctf_event_class_get_field_type(*args)
_bt_python_ctf_event_class_get_field_type = _babeltrace._bt_python_ctf_event_class_get_field_type

def _bt_context_create():
  return _babeltrace._bt_context_create()
_bt_context_create = _babeltrace._bt_context_create

def _bt_context_add_trace(*args):
  return _babeltrace._bt_context_add_trace(*args)
_bt_context_add_trace = _babeltrace._bt_context_add_trace

def _bt_context_remove_trace(*args):
  return _babeltrace._bt_context_remove_trace(*args)
_bt_context_remove_trace = _babeltrace._bt_context_remove_trace

def _bt_context_get(*args):
  return _babeltrace._bt_context_get(*args)
_bt_context_get = _babeltrace._bt_context_get

def _bt_context_put(*args):
  return _babeltrace._bt_context_put(*args)
_bt_context_put = _babeltrace._bt_context_put

def _bt_ctf_event_get_context(*args):
  return _babeltrace._bt_ctf_event_get_context(*args)
_bt_ctf_event_get_context = _babeltrace._bt_ctf_event_get_context
class TraceCollection:
	"""
	The TraceCollection is the object that contains all currently opened traces.
	"""

	def __init__(self):
		self._tc = _bt_context_create()

	def __del__(self):
		_bt_context_put(self._tc)

	def add_trace(self, path, format_str):
		"""
		Add a trace by path to the TraceCollection.

		Open a trace.

		path is the path to the trace, it is not recursive.
		If "path" is None, stream_list is used instead as a list
		of mmap streams to open for the trace.

		format is a string containing the format name in which the trace was
		produced.

		Return: the corresponding TraceHandle on success or None on error.
		"""
		ret = _bt_context_add_trace(self._tc, path, format_str, None, None, None)
		if ret < 0:
			return None

		th = TraceHandle.__new__(TraceHandle)
		th._id = ret
		th._trace_collection = self
		return th

	def add_traces_recursive(self, path, format_str):
		"""
		Open a trace recursively.

		Find each trace present in the subdirectory starting from the given
		path, and add them to the TraceCollection.

		Return a dict of TraceHandle instances (the full path is the key).
		Return None on error.
		"""

		import os

		trace_handles = {}

		noTrace = True
		error = False

		for fullpath, dirs, files in os.walk(path):
			if "metadata" in files:
				trace_handle = self.add_trace(fullpath, format_str)
				if trace_handle is None:
					error = True
					continue

				trace_handles[fullpath] = trace_handle
				noTrace = False

		if noTrace and error:
			return None
		return trace_handles

	def remove_trace(self, trace_handle):
		"""
		Remove a trace from the TraceCollection.
		Effectively closing the trace.
		"""
		try:
			_bt_context_remove_trace(self._tc, trace_handle._id)
		except AttributeError:
			raise TypeError("in remove_trace, "
				"argument 2 must be a TraceHandle instance")

	@property
	def events(self):
		"""
		Generator function to iterate over the events of open in the current
		TraceCollection.
		"""
		begin_pos_ptr = _bt_iter_pos()
		end_pos_ptr = _bt_iter_pos()
		begin_pos_ptr.type = SEEK_BEGIN
		end_pos_ptr.type = SEEK_LAST

		for event in self._events(begin_pos_ptr, end_pos_ptr):
			yield event

	def events_timestamps(self, timestamp_begin, timestamp_end):
		"""
		Generator function to iterate over the events of open in the current
		TraceCollection from timestamp_begin to timestamp_end.
		"""
		begin_pos_ptr = _bt_iter_pos()
		end_pos_ptr = _bt_iter_pos()
		begin_pos_ptr.type = end_pos_ptr.type = SEEK_TIME
		begin_pos_ptr.u.seek_time = timestamp_begin
		end_pos_ptr.u.seek_time = timestamp_end

		for event in self._events(begin_pos_ptr, end_pos_ptr):
			yield event

	@property
	def timestamp_begin(self):
		pos_ptr = _bt_iter_pos()
		pos_ptr.type = SEEK_BEGIN
		return self._timestamp_at_pos(pos_ptr)

	@property
	def timestamp_end(self):
		pos_ptr = _bt_iter_pos()
		pos_ptr.type = SEEK_LAST
		return self._timestamp_at_pos(pos_ptr)

	def _timestamp_at_pos(self, pos_ptr):
		ctf_it_ptr = _bt_ctf_iter_create(self._tc, pos_ptr, pos_ptr)
		if ctf_it_ptr is None:
			raise NotImplementedError("Creation of multiple iterators is unsupported.")
		ev_ptr = _bt_ctf_iter_read_event(ctf_it_ptr)
		_bt_ctf_iter_destroy(ctf_it_ptr)
		if ev_ptr is None:
			return None;

	def _events(self, begin_pos_ptr, end_pos_ptr):
		ctf_it_ptr = _bt_ctf_iter_create(self._tc, begin_pos_ptr, end_pos_ptr)
		if ctf_it_ptr is None:
			raise NotImplementedError(
				"Creation of multiple iterators is unsupported.")

		while True:
			ev_ptr = _bt_ctf_iter_read_event(ctf_it_ptr)
			if ev_ptr is None:
				break

			ev = Event.__new__(Event)
			ev._e = ev_ptr
			try:
				yield ev
			except GeneratorExit:
				break

			ret = _bt_iter_next(_bt_ctf_get_iter(ctf_it_ptr))
			if ret != 0:
				break

		_bt_ctf_iter_destroy(ctf_it_ptr)



def lookup_format(*args):
  return _babeltrace.lookup_format(*args)
lookup_format = _babeltrace.lookup_format

def _bt_print_format_list(*args):
  return _babeltrace._bt_print_format_list(*args)
_bt_print_format_list = _babeltrace._bt_print_format_list

def bt_register_format(*args):
  return _babeltrace.bt_register_format(*args)
bt_register_format = _babeltrace.bt_register_format

def unregister_format(*args):
  return _babeltrace.unregister_format(*args)
unregister_format = _babeltrace.unregister_format
def print_format_list(babeltrace_file):
	"""
	Print a list of available formats to file.

	babeltrace_file must be a File instance opened in write mode.
	"""
	try:
		if babeltrace_file._file is not None:
			_bt_print_format_list(babeltrace_file._file)
	except AttributeError:
		raise TypeError("in print_format_list, "
			"argument 1 must be a File instance")



def _bt_iter_create(*args):
  return _babeltrace._bt_iter_create(*args)
_bt_iter_create = _babeltrace._bt_iter_create

def _bt_iter_destroy(*args):
  return _babeltrace._bt_iter_destroy(*args)
_bt_iter_destroy = _babeltrace._bt_iter_destroy

def _bt_iter_next(*args):
  return _babeltrace._bt_iter_next(*args)
_bt_iter_next = _babeltrace._bt_iter_next

def _bt_iter_get_pos(*args):
  return _babeltrace._bt_iter_get_pos(*args)
_bt_iter_get_pos = _babeltrace._bt_iter_get_pos

def _bt_iter_free_pos(*args):
  return _babeltrace._bt_iter_free_pos(*args)
_bt_iter_free_pos = _babeltrace._bt_iter_free_pos

def _bt_iter_set_pos(*args):
  return _babeltrace._bt_iter_set_pos(*args)
_bt_iter_set_pos = _babeltrace._bt_iter_set_pos

def _bt_iter_create_time_pos(*args):
  return _babeltrace._bt_iter_create_time_pos(*args)
_bt_iter_create_time_pos = _babeltrace._bt_iter_create_time_pos
class _bt_iter_pos(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _bt_iter_pos, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _bt_iter_pos, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _babeltrace._bt_iter_pos_type_set
    __swig_getmethods__["type"] = _babeltrace._bt_iter_pos_type_get
    if _newclass:type = _swig_property(_babeltrace._bt_iter_pos_type_get, _babeltrace._bt_iter_pos_type_set)
    __swig_getmethods__["u"] = _babeltrace._bt_iter_pos_u_get
    if _newclass:u = _swig_property(_babeltrace._bt_iter_pos_u_get)
    def __init__(self): 
        this = _babeltrace.new__bt_iter_pos()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _babeltrace.delete__bt_iter_pos
    __del__ = lambda self : None;
_bt_iter_pos_swigregister = _babeltrace._bt_iter_pos_swigregister
_bt_iter_pos_swigregister(_bt_iter_pos)
SEEK_TIME = _babeltrace.SEEK_TIME
SEEK_RESTORE = _babeltrace.SEEK_RESTORE
SEEK_CUR = _babeltrace.SEEK_CUR
SEEK_BEGIN = _babeltrace.SEEK_BEGIN
SEEK_LAST = _babeltrace.SEEK_LAST

class bt_iter_pos_u(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, bt_iter_pos_u, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, bt_iter_pos_u, name)
    __repr__ = _swig_repr
    __swig_setmethods__["seek_time"] = _babeltrace.bt_iter_pos_u_seek_time_set
    __swig_getmethods__["seek_time"] = _babeltrace.bt_iter_pos_u_seek_time_get
    if _newclass:seek_time = _swig_property(_babeltrace.bt_iter_pos_u_seek_time_get, _babeltrace.bt_iter_pos_u_seek_time_set)
    __swig_setmethods__["restore"] = _babeltrace.bt_iter_pos_u_restore_set
    __swig_getmethods__["restore"] = _babeltrace.bt_iter_pos_u_restore_get
    if _newclass:restore = _swig_property(_babeltrace.bt_iter_pos_u_restore_get, _babeltrace.bt_iter_pos_u_restore_set)
    def __init__(self): 
        this = _babeltrace.new_bt_iter_pos_u()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _babeltrace.delete_bt_iter_pos_u
    __del__ = lambda self : None;
bt_iter_pos_u_swigregister = _babeltrace.bt_iter_pos_u_swigregister
bt_iter_pos_u_swigregister(bt_iter_pos_u)


def _bt_trace_handle_create(*args):
  return _babeltrace._bt_trace_handle_create(*args)
_bt_trace_handle_create = _babeltrace._bt_trace_handle_create

def _bt_trace_handle_destroy(*args):
  return _babeltrace._bt_trace_handle_destroy(*args)
_bt_trace_handle_destroy = _babeltrace._bt_trace_handle_destroy

def _bt_trace_handle_get_path(*args):
  return _babeltrace._bt_trace_handle_get_path(*args)
_bt_trace_handle_get_path = _babeltrace._bt_trace_handle_get_path

def _bt_trace_handle_get_timestamp_begin(*args):
  return _babeltrace._bt_trace_handle_get_timestamp_begin(*args)
_bt_trace_handle_get_timestamp_begin = _babeltrace._bt_trace_handle_get_timestamp_begin

def _bt_trace_handle_get_timestamp_end(*args):
  return _babeltrace._bt_trace_handle_get_timestamp_end(*args)
_bt_trace_handle_get_timestamp_end = _babeltrace._bt_trace_handle_get_timestamp_end

def _bt_ctf_event_get_handle_id(*args):
  return _babeltrace._bt_ctf_event_get_handle_id(*args)
_bt_ctf_event_get_handle_id = _babeltrace._bt_ctf_event_get_handle_id
# Based on enum bt_clock_type in clock-type.h
class ClockType:
	CLOCK_CYCLES = 0
	CLOCK_REAL = 1

class TraceHandle(object):
	"""
	The TraceHandle allows the user to manipulate a trace file directly.
	It is a unique identifier representing a trace file.
	Do not instantiate.
	"""

	def __init__(self):
		raise NotImplementedError("TraceHandle cannot be instantiated")

	def __repr__(self):
		return "Babeltrace TraceHandle: trace_id('{0}')".format(self._id)

	@property
	def id(self):
		"""Return the TraceHandle id."""
		return self._id

	@property
	def path(self):
		"""Return the path of a TraceHandle."""
		return _bt_trace_handle_get_path(self._trace_collection._tc, self._id)

	@property
	def timestamp_begin(self):
		"""Return the creation time of the buffers of a trace."""
		return _bt_trace_handle_get_timestamp_begin(
			self._trace_collection._tc, self._id, ClockType.CLOCK_REAL)

	@property
	def timestamp_end(self):
		"""Return the destruction timestamp of the buffers of a trace."""
		return _bt_trace_handle_get_timestamp_end(
			self._trace_collection._tc, self._id, ClockType.CLOCK_REAL)

	@property
	def events(self):
		"""
		Generator returning all events (EventDeclaration) in a trace.
		"""
		ret = _bt_python_event_decl_listcaller(self.id, self._trace_collection._tc)

		if not isinstance(ret, list):
			return

		ptr_list, count = ret
		for i in range(count):
			tmp = EventDeclaration.__new__(EventDeclaration)
			tmp._ed =  _bt_python_decl_one_from_list(ptr_list, i)
			yield tmp



def _bt_ctf_iter_create(*args):
  return _babeltrace._bt_ctf_iter_create(*args)
_bt_ctf_iter_create = _babeltrace._bt_ctf_iter_create

def _bt_ctf_get_iter(*args):
  return _babeltrace._bt_ctf_get_iter(*args)
_bt_ctf_get_iter = _babeltrace._bt_ctf_get_iter

def _bt_ctf_iter_destroy(*args):
  return _babeltrace._bt_ctf_iter_destroy(*args)
_bt_ctf_iter_destroy = _babeltrace._bt_ctf_iter_destroy

def _bt_ctf_iter_read_event(*args):
  return _babeltrace._bt_ctf_iter_read_event(*args)
_bt_ctf_iter_read_event = _babeltrace._bt_ctf_iter_read_event

def _bt_ctf_get_top_level_scope(*args):
  return _babeltrace._bt_ctf_get_top_level_scope(*args)
_bt_ctf_get_top_level_scope = _babeltrace._bt_ctf_get_top_level_scope

def _bt_ctf_event_name(*args):
  return _babeltrace._bt_ctf_event_name(*args)
_bt_ctf_event_name = _babeltrace._bt_ctf_event_name

def _bt_ctf_get_timestamp(*args):
  return _babeltrace._bt_ctf_get_timestamp(*args)
_bt_ctf_get_timestamp = _babeltrace._bt_ctf_get_timestamp

def _bt_ctf_get_cycles(*args):
  return _babeltrace._bt_ctf_get_cycles(*args)
_bt_ctf_get_cycles = _babeltrace._bt_ctf_get_cycles

def _bt_ctf_get_field(*args):
  return _babeltrace._bt_ctf_get_field(*args)
_bt_ctf_get_field = _babeltrace._bt_ctf_get_field

def _bt_ctf_get_index(*args):
  return _babeltrace._bt_ctf_get_index(*args)
_bt_ctf_get_index = _babeltrace._bt_ctf_get_index

def _bt_ctf_field_name(*args):
  return _babeltrace._bt_ctf_field_name(*args)
_bt_ctf_field_name = _babeltrace._bt_ctf_field_name

def _bt_ctf_field_type(*args):
  return _babeltrace._bt_ctf_field_type(*args)
_bt_ctf_field_type = _babeltrace._bt_ctf_field_type

def _bt_ctf_get_int_signedness(*args):
  return _babeltrace._bt_ctf_get_int_signedness(*args)
_bt_ctf_get_int_signedness = _babeltrace._bt_ctf_get_int_signedness

def _bt_ctf_get_int_base(*args):
  return _babeltrace._bt_ctf_get_int_base(*args)
_bt_ctf_get_int_base = _babeltrace._bt_ctf_get_int_base

def _bt_ctf_get_int_byte_order(*args):
  return _babeltrace._bt_ctf_get_int_byte_order(*args)
_bt_ctf_get_int_byte_order = _babeltrace._bt_ctf_get_int_byte_order

def _bt_ctf_get_int_len(*args):
  return _babeltrace._bt_ctf_get_int_len(*args)
_bt_ctf_get_int_len = _babeltrace._bt_ctf_get_int_len

def _bt_ctf_get_enum_int(*args):
  return _babeltrace._bt_ctf_get_enum_int(*args)
_bt_ctf_get_enum_int = _babeltrace._bt_ctf_get_enum_int

def _bt_ctf_get_enum_str(*args):
  return _babeltrace._bt_ctf_get_enum_str(*args)
_bt_ctf_get_enum_str = _babeltrace._bt_ctf_get_enum_str

def _bt_ctf_get_encoding(*args):
  return _babeltrace._bt_ctf_get_encoding(*args)
_bt_ctf_get_encoding = _babeltrace._bt_ctf_get_encoding

def _bt_ctf_get_array_len(*args):
  return _babeltrace._bt_ctf_get_array_len(*args)
_bt_ctf_get_array_len = _babeltrace._bt_ctf_get_array_len

def _bt_array_index(*args):
  return _babeltrace._bt_array_index(*args)
_bt_array_index = _babeltrace._bt_array_index

def _bt_ctf_get_uint64(*args):
  return _babeltrace._bt_ctf_get_uint64(*args)
_bt_ctf_get_uint64 = _babeltrace._bt_ctf_get_uint64

def _bt_ctf_get_int64(*args):
  return _babeltrace._bt_ctf_get_int64(*args)
_bt_ctf_get_int64 = _babeltrace._bt_ctf_get_int64

def _bt_ctf_get_char_array(*args):
  return _babeltrace._bt_ctf_get_char_array(*args)
_bt_ctf_get_char_array = _babeltrace._bt_ctf_get_char_array

def _bt_ctf_get_string(*args):
  return _babeltrace._bt_ctf_get_string(*args)
_bt_ctf_get_string = _babeltrace._bt_ctf_get_string

def _bt_ctf_get_float(*args):
  return _babeltrace._bt_ctf_get_float(*args)
_bt_ctf_get_float = _babeltrace._bt_ctf_get_float

def _bt_ctf_get_variant(*args):
  return _babeltrace._bt_ctf_get_variant(*args)
_bt_ctf_get_variant = _babeltrace._bt_ctf_get_variant

def _bt_ctf_field_get_error():
  return _babeltrace._bt_ctf_field_get_error()
_bt_ctf_field_get_error = _babeltrace._bt_ctf_field_get_error

def _bt_ctf_get_decl_event_name(*args):
  return _babeltrace._bt_ctf_get_decl_event_name(*args)
_bt_ctf_get_decl_event_name = _babeltrace._bt_ctf_get_decl_event_name

def _bt_ctf_get_decl_event_id(*args):
  return _babeltrace._bt_ctf_get_decl_event_id(*args)
_bt_ctf_get_decl_event_id = _babeltrace._bt_ctf_get_decl_event_id

def _bt_ctf_get_decl_field_name(*args):
  return _babeltrace._bt_ctf_get_decl_field_name(*args)
_bt_ctf_get_decl_field_name = _babeltrace._bt_ctf_get_decl_field_name

def _bt_ctf_get_decl_from_def(*args):
  return _babeltrace._bt_ctf_get_decl_from_def(*args)
_bt_ctf_get_decl_from_def = _babeltrace._bt_ctf_get_decl_from_def

def _bt_ctf_get_decl_from_field_decl(*args):
  return _babeltrace._bt_ctf_get_decl_from_field_decl(*args)
_bt_ctf_get_decl_from_field_decl = _babeltrace._bt_ctf_get_decl_from_field_decl

def _bt_sequence_len(*args):
  return _babeltrace._bt_sequence_len(*args)
_bt_sequence_len = _babeltrace._bt_sequence_len

def _bt_sequence_index(*args):
  return _babeltrace._bt_sequence_index(*args)
_bt_sequence_index = _babeltrace._bt_sequence_index

def _bt_ctf_get_struct_field_count(*args):
  return _babeltrace._bt_ctf_get_struct_field_count(*args)
_bt_ctf_get_struct_field_count = _babeltrace._bt_ctf_get_struct_field_count

def _bt_ctf_get_struct_field_index(*args):
  return _babeltrace._bt_ctf_get_struct_field_index(*args)
_bt_ctf_get_struct_field_index = _babeltrace._bt_ctf_get_struct_field_index
class CTFStringEncoding:
	NONE = 0
	UTF8 = 1
	ASCII = 2
	UNKNOWN = 3

# Based on the enum in ctf-writer/writer.h
class ByteOrder:
	BYTE_ORDER_NATIVE = 0
	BYTE_ORDER_LITTLE_ENDIAN = 1
	BYTE_ORDER_BIG_ENDIAN = 2
	BYTE_ORDER_NETWORK = 3
	BYTE_ORDER_UNKNOWN = 4 # Python-specific entry

#enum equivalent, accessible constants
#These are taken directly from ctf/events.h
#All changes to enums must also be made here
class CTFTypeId:
	UNKNOWN = 0
	INTEGER = 1
	FLOAT = 2
	ENUM = 3
	STRING = 4
	STRUCT = 5
	UNTAGGED_VARIANT = 6
	VARIANT = 7
	ARRAY = 8
	SEQUENCE = 9
	NR_CTF_TYPES = 10
	def type_name(id):
		name = "UNKNOWN_TYPE"
		constants = [attr for attr in dir(CTFTypeId) if not callable(getattr(CTFTypeId, attr)) and not attr.startswith("__")]
		for attr in constants:
			if getattr(CTFTypeId, attr) == id:
				name = attr
				break
		return name

class CTFScope:
	TRACE_PACKET_HEADER = 0
	STREAM_PACKET_CONTEXT = 1
	STREAM_EVENT_HEADER = 2
	STREAM_EVENT_CONTEXT = 3
	EVENT_CONTEXT = 4
	EVENT_FIELDS = 5

	def scope_name(scope):
		name = "UNKNOWN_SCOPE"
		constants = [attr for attr in dir(CTFScope) if not callable(getattr(CTFScope, attr)) and not attr.startswith("__")]
		for attr in constants:
			if getattr(CTFScope, attr) == scope:
				name = attr
				break
		return name

# Priority of the scopes when searching for event fields
_scopes = [CTFScope.EVENT_FIELDS, CTFScope.EVENT_CONTEXT, CTFScope.STREAM_EVENT_CONTEXT,
	CTFScope.STREAM_EVENT_HEADER, CTFScope.STREAM_PACKET_CONTEXT, CTFScope.TRACE_PACKET_HEADER]

import collections
class Event(collections.Mapping):
	"""
	This class represents an event from the trace.
	It is obtained using the TraceCollection generator functions.
	Do not instantiate.
	"""
	def __init__(self):
		raise NotImplementedError("Event cannot be instantiated")

	@property
	def name(self):
		"""Return the name of the event or None on error."""
		return _bt_ctf_event_name(self._e)

	@property
	def cycles(self):
		"""
		Return the timestamp of the event as written in
		the packet (in cycles) or -1ULL on error.
		"""
		return _bt_ctf_get_cycles(self._e)

	@property
	def timestamp(self):
		"""
		Return the timestamp of the event offset with the
		system clock source or -1ULL on error.
		"""
		return _bt_ctf_get_timestamp(self._e)

	def field_with_scope(self, field_name, scope):
		"""
		Get field_name's value in scope.
		None is returned if no field matches field_name.
		"""
		if not scope in _scopes:
			raise ValueError("Invalid scope provided")
		field = self._field_with_scope(field_name, scope)
		if field is not None:
			return field.value
		return None

	def field_list_with_scope(self, scope):
		"""Return a list of field names in scope."""
		if not scope in _scopes:
			raise ValueError("Invalid scope provided")
		field_names = []
		for field in self._field_list_with_scope(scope):
			field_names.append(field.name)
		return field_names

	@property
	def handle(self):
		"""
		Get the TraceHandle associated with this event
		Return None on error
		"""
		ret = _bt_ctf_event_get_handle_id(self._e)
		if ret < 0:
			return None

		th = TraceHandle.__new__(TraceHandle)
		th._id = ret
		th._trace_collection = self.get_trace_collection()
		return th

	@property
	def trace_collection(self):
		"""
		Get the TraceCollection associated with this event.
		Return None on error.
		"""
		trace_collection = TraceCollection()
		trace_collection._tc = _bt_ctf_event_get_context(self._e);
		if trace_collection._tc is None:
			return None
		else:
			return trace_collection

	def __getitem__(self, field_name):
		"""
		Get field_name's value. If the field_name exists in multiple
		scopes, the first field found is returned. The scopes are searched
		in the following order:
		1) EVENT_FIELDS
		2) EVENT_CONTEXT
		3) STREAM_EVENT_CONTEXT
		4) STREAM_EVENT_HEADER
		5) STREAM_PACKET_CONTEXT
		6) TRACE_PACKET_HEADER
		None is returned if no field matches field_name.

		Use field_with_scope() to explicitly access fields in a given
		scope.
		"""
		field = self._field(field_name)
		if field is not None:
			return field.value
		raise KeyError(field_name)

	def __iter__(self):
		for key in self.keys():
			yield key

	def __len__(self):
		count = 0
		for scope in _scopes:
			scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
			ret = _bt_python_field_listcaller(self._e, scope_ptr)
			if isinstance(ret, list):
				count += ret[1]
		return count

	def __contains__(self, field_name):
		return self._field(field_name) is not None

	def keys(self):
		"""Return a list of field names."""
		field_names = set()
		for scope in _scopes:
			for name in self.field_list_with_scope(scope):
				field_names.add(name)
		return list(field_names)

	def get(self, field_name, default = None):
		field = self._field(field_name)
		if field is None:
			return default
		return field.value

	def items(self):
		for field in self.keys():
			yield (field, self[field])

	def _field_with_scope(self, field_name, scope):
		scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
		if scope_ptr is None:
			return None

		definition_ptr = _bt_ctf_get_field(self._e, scope_ptr, field_name)
		if definition_ptr is None:
			return None

		field = _Definition(definition_ptr, scope)
		return field

	def _field(self, field_name):
		field = None
		for scope in _scopes:
			field = self._field_with_scope(field_name, scope)
			if field is not None:
				break
		return field

	def _field_list_with_scope(self, scope):
		fields = []
		scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
		
		# Returns a list [list_ptr, count]. If list_ptr is NULL, SWIG will only
		# provide the "count" return value
		count = 0
		list_ptr = None
		ret = _bt_python_field_listcaller(self._e, scope_ptr)
		if isinstance(ret, list):
			list_ptr, count = ret

		for i in range(count):
			definition_ptr = _bt_python_field_one_from_list(list_ptr, i)
			if definition_ptr is not None:
				definition = _Definition(definition_ptr, scope)
				fields.append(definition)
		return fields

class FieldError(Exception):
	def __init__(self, value):
		self.value = value

	def __str__(self):
		return repr(self.value)

class EventDeclaration(object):
	"""Event declaration class.  Do not instantiate."""
	MAX_UINT64 = 0xFFFFFFFFFFFFFFFF

	def __init__(self):
		raise NotImplementedError("EventDeclaration cannot be instantiated")

	@property
	def name(self):
		"""Return the name of the event or None on error"""
		return _bt_ctf_get_decl_event_name(self._ed)

	@property
	def id(self):
		"""Return the event-ID of the event or -1 on error"""
		id = _bt_ctf_get_decl_event_id(self._ed)
		if id == self.MAX_UINT64:
			id = -1
		return id

	@property
	def fields(self):
		"""
		Generator returning all FieldDeclarations of an event, going through
		each scope in the following order:
		1) EVENT_FIELDS
		2) EVENT_CONTEXT
		3) STREAM_EVENT_CONTEXT
		4) STREAM_EVENT_HEADER
		5) STREAM_PACKET_CONTEXT
		6) TRACE_PACKET_HEADER
		"""
		for scope in _scopes:
			for declaration in self.fields_scope(scope):
				yield declaration

	def fields_scope(self, scope):
		"""
		Generator returning FieldDeclarations of the current event in scope.
		"""
		ret = _by_python_field_decl_listcaller(self._ed, scope)

		if not isinstance(ret, list):
			return

		list_ptr, count = ret
		for i in range(count):
			field_declaration_ptr = _bt_python_field_decl_one_from_list(list_ptr, i)
			if field_declaration_ptr is not None:
				declaration_ptr = _bt_ctf_get_decl_from_field_decl(field_declaration_ptr)
				field_declaration = _create_field_declaration(declaration_ptr, _bt_ctf_get_decl_field_name(field_declaration_ptr), scope)
				yield field_declaration

class FieldDeclaration(object):
	"""Field declaration class. Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("FieldDeclaration cannot be instantiated")

	def __repr__(self):
		return "({0}) {1} {2}".format(CTFScope.scope_name(self.scope), CTFTypeId.type_name(self.type), self.name)

	@property
	def name(self):
		"""Return the name of a FieldDeclaration or None on error."""
		return self._name

	@property
	def type(self):
		"""
		Return the FieldDeclaration's type. One of the entries in class
		CTFTypeId.
		"""
		return _bt_ctf_field_type(self._fd)

	@property
	def scope(self):
		"""
		Return the FieldDeclaration's scope.
		"""
		return self._s

class IntegerFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("IntegerFieldDeclaration cannot be instantiated")

	@property
	def signedness(self):
		"""
		Return the signedness of an integer:
		0 if unsigned; 1 if signed; -1 on error.
		"""
		return _bt_ctf_get_int_signedness(self._fd)

	@property
	def base(self):
		"""Return the base of an int or a negative value on error."""
		return _bt_ctf_get_int_base(self._fd)

	@property
	def byte_order(self):
		"""
		Return the byte order. One of class ByteOrder's entries.
		"""
		ret = _bt_ctf_get_int_byte_order(self._fd)
		if ret == 1234:
			return ByteOrder.BYTE_ORDER_LITTLE_ENDIAN
		elif ret == 4321:
			return ByteOrder.BYTE_ORDER_BIG_ENDIAN
		else:
			return ByteOrder.BYTE_ORDER_UNKNOWN

	@property
	def length(self):
		"""
		Return the size, in bits, of an int or a negative
		value on error.
		"""
		return _bt_ctf_get_int_len(self._fd)

	@property
	def encoding(self):
		"""
		Return the encoding. One of class CTFStringEncoding's entries.
		Return a negative value on error.
		"""
		return _bt_ctf_get_encoding(self._fd)

class EnumerationFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("EnumerationFieldDeclaration cannot be instantiated")

class ArrayFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("ArrayFieldDeclaration cannot be instantiated")

	@property
	def length(self):
		"""
		Return the length of an array or a negative
		value on error.
		"""
		return _bt_ctf_get_array_len(self._fd)

	@property
	def element_declaration(self):
		"""
		Return element declaration.
		"""
		field_decl_ptr = _bt_python_get_array_element_declaration(self._fd)
		return _create_field_declaration(field_decl_ptr, "", self.scope)

class SequenceFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("SequenceFieldDeclaration cannot be instantiated")

	@property
	def element_declaration(self):
		"""
		Return element declaration.
		"""
		field_decl_ptr = _bt_python_get_sequence_element_declaration(self._fd)
		return _create_field_declaration(field_decl_ptr, "", self.scope)

class FloatFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("FloatFieldDeclaration cannot be instantiated")

class StructureFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("StructureFieldDeclaration cannot be instantiated")

class StringFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("StringFieldDeclaration cannot be instantiated")

class VariantFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("VariantFieldDeclaration cannot be instantiated")

def field_error():
	"""
	Return the last error code encountered while
	accessing a field and reset the error flag.
	Return 0 if no error, a negative value otherwise.
	"""
	return _bt_ctf_field_get_error()

def _create_field_declaration(declaration_ptr, name, scope):
	"""
	Private field declaration factory.
	"""
	if declaration_ptr is None:
		raise ValueError("declaration_ptr must be valid")
	if not scope in _scopes:
		raise ValueError("Invalid scope provided")

	type = _bt_ctf_field_type(declaration_ptr)
	declaration = None
	if type == CTFTypeId.INTEGER:
		declaration = IntegerFieldDeclaration.__new__(IntegerFieldDeclaration)
	elif type == CTFTypeId.ENUM:
		declaration = EnumerationFieldDeclaration.__new__(EnumerationFieldDeclaration)
	elif type == CTFTypeId.ARRAY:
		declaration = ArrayFieldDeclaration.__new__(ArrayFieldDeclaration)
	elif type == CTFTypeId.SEQUENCE:
		declaration = SequenceFieldDeclaration.__new__(SequenceFieldDeclaration)
	elif type == CTFTypeId.FLOAT:
		declaration = FloatFieldDeclaration.__new__(FloatFieldDeclaration)
	elif type == CTFTypeId.STRUCT:
		declaration = StructureFieldDeclaration.__new__(StructureFieldDeclaration)
	elif type == CTFTypeId.STRING:
		declaration = StringFieldDeclaration.__new__(StringFieldDeclaration)
	elif type == CTFTypeId.VARIANT:
		declaration = VariantFieldDeclaration.__new__(VariantFieldDeclaration)
	else:
		return declaration

	declaration._fd = declaration_ptr
	declaration._s = scope
	declaration._name = name
	return declaration

class _Definition(object):
	def __init__(self, definition_ptr, scope):
		self._d = definition_ptr
		self._s = scope
		if not scope in _scopes:
			ValueError("Invalid scope provided")

	@property
	def name(self):
		"""Return the name of a field or None on error."""
		return _bt_ctf_field_name(self._d)

	@property
	def type(self):
		"""Return the type of a field or -1 if unknown."""
		return _bt_ctf_field_type(_bt_ctf_get_decl_from_def(self._d))

	@property
	def declaration(self):
		"""Return the associated Definition object."""
		return _create_field_declaration(_bt_ctf_get_decl_from_def(self._d), self.name, self.scope)

	def _get_enum_str(self):
		"""
		Return the string matching the current enumeration.
		Return None on error.
		"""
		return _bt_ctf_get_enum_str(self._d)

	def _get_array_element_at(self, index):
		"""
		Return the array's element at position index.
		Return None on error
		"""
		array_ptr = _bt_python_get_array_from_def(self._d)
		if array_ptr is None:
			return None

		definition_ptr = _bt_array_index(array_ptr, index)
		if definition_ptr is None:
			return None
		return _Definition(definition_ptr, self.scope)

	def _get_sequence_len(self):
		"""
		Return the len of a sequence or a negative
		value on error.
		"""
		seq = _bt_python_get_sequence_from_def(self._d)
		return _bt_sequence_len(seq)

	def _get_sequence_element_at(self, index):
		"""
		Return the sequence's element at position index,
		otherwise return None
		"""
		seq = _bt_python_get_sequence_from_def(self._d)
		if seq is not None:
			definition_ptr = _bt_sequence_index(seq, index)
			if definition_ptr is not None:
				return _Definition(definition_ptr, self.scope)
		return None

	def _get_uint64(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occured,
		use the	field_error() function after accessing a field.
		"""
		return _bt_ctf_get_uint64(self._d)

	def _get_int64(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occured,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_int64(self._d)

	def _get_char_array(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_char_array(self._d)

	def _get_str(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_string(self._d)

	def _get_float(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_float(self._d)

	def _get_variant(self):
		"""
		Return the variant's selected field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_variant(self._d)

	def _get_struct_field_count(self):
		"""
		Return the number of fields contained in the structure.
		If the field does not exist or is not of the type requested,
		the value returned is undefined.
		"""
		return _bt_ctf_get_struct_field_count(self._d)

	def _get_struct_field_at(self, i):
		"""
		Return the structure's field at position i.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_struct_field_index(self._d, i)

	@property
	def value(self):
		"""
		Return the value associated with the field according to its type.
		Return None on error.
		"""
		id = self.type
		value = None

		if id == CTFTypeId.STRING:
			value = self._get_str()
		elif id == CTFTypeId.ARRAY:
			element_decl = self.declaration.element_declaration
			if ((element_decl.type == CTFTypeId.INTEGER
				and element_decl.length == 8)
				and (element_decl.encoding == CTFStringEncoding.ASCII or element_decl.encoding == CTFStringEncoding.UTF8)):
				value = _bt_python_get_array_string(self._d)
			else:
				value = []
				for i in range(self.declaration.length):
					element = self._get_array_element_at(i)
					value.append(element.value)
		elif id == CTFTypeId.INTEGER:
			if self.declaration.signedness == 0:
				value = self._get_uint64()
			else:
				value = self._get_int64()
		elif id == CTFTypeId.ENUM:
			value = self._get_enum_str()
		elif id == CTFTypeId.SEQUENCE:
			element_decl = self.declaration.element_declaration
			if ((element_decl.type == CTFTypeId.INTEGER
				and element_decl.length == 8)
				and (element_decl.encoding == CTFStringEncoding.ASCII or element_decl.encoding == CTFStringEncoding.UTF8)):
				value = _bt_python_get_sequence_string(self._d)
			else:
				seq_len = self._get_sequence_len()
				value = []
				for i in range(seq_len):
					evDef = self._get_sequence_element_at(i)
					value.append(evDef.value)
		elif id == CTFTypeId.FLOAT:
			value = self._get_float()
		elif id == CTFTypeId.VARIANT:
			variant = _Definition.__new__(_Definition)
			variant._d = self._get_variant();
			value = variant.value
		elif id == CTFTypeId.STRUCT:
			value = {}
			for i in range(self._get_struct_field_count()):
				member = _Definition(self._get_struct_field_at(i), self.scope)
				value[member.name] = member.value

		if field_error():
			raise FieldError("Error occurred while accessing field {} of type {}".format(self.name, CTFTypeId.type_name(id)))
		return value

	@property
	def scope(self):
		"""Return the scope of a field or None on error."""
		return self._s



def _bt_ctf_clock_create(*args):
  return _babeltrace._bt_ctf_clock_create(*args)
_bt_ctf_clock_create = _babeltrace._bt_ctf_clock_create

def _bt_ctf_clock_get_name(*args):
  return _babeltrace._bt_ctf_clock_get_name(*args)
_bt_ctf_clock_get_name = _babeltrace._bt_ctf_clock_get_name

def _bt_ctf_clock_get_description(*args):
  return _babeltrace._bt_ctf_clock_get_description(*args)
_bt_ctf_clock_get_description = _babeltrace._bt_ctf_clock_get_description

def _bt_ctf_clock_set_description(*args):
  return _babeltrace._bt_ctf_clock_set_description(*args)
_bt_ctf_clock_set_description = _babeltrace._bt_ctf_clock_set_description

def _bt_ctf_clock_get_frequency(*args):
  return _babeltrace._bt_ctf_clock_get_frequency(*args)
_bt_ctf_clock_get_frequency = _babeltrace._bt_ctf_clock_get_frequency

def _bt_ctf_clock_set_frequency(*args):
  return _babeltrace._bt_ctf_clock_set_frequency(*args)
_bt_ctf_clock_set_frequency = _babeltrace._bt_ctf_clock_set_frequency

def _bt_ctf_clock_get_precision(*args):
  return _babeltrace._bt_ctf_clock_get_precision(*args)
_bt_ctf_clock_get_precision = _babeltrace._bt_ctf_clock_get_precision

def _bt_ctf_clock_set_precision(*args):
  return _babeltrace._bt_ctf_clock_set_precision(*args)
_bt_ctf_clock_set_precision = _babeltrace._bt_ctf_clock_set_precision

def _bt_ctf_clock_get_offset_s(*args):
  return _babeltrace._bt_ctf_clock_get_offset_s(*args)
_bt_ctf_clock_get_offset_s = _babeltrace._bt_ctf_clock_get_offset_s

def _bt_ctf_clock_set_offset_s(*args):
  return _babeltrace._bt_ctf_clock_set_offset_s(*args)
_bt_ctf_clock_set_offset_s = _babeltrace._bt_ctf_clock_set_offset_s

def _bt_ctf_clock_get_offset(*args):
  return _babeltrace._bt_ctf_clock_get_offset(*args)
_bt_ctf_clock_get_offset = _babeltrace._bt_ctf_clock_get_offset

def _bt_ctf_clock_set_offset(*args):
  return _babeltrace._bt_ctf_clock_set_offset(*args)
_bt_ctf_clock_set_offset = _babeltrace._bt_ctf_clock_set_offset

def _bt_ctf_clock_get_is_absolute(*args):
  return _babeltrace._bt_ctf_clock_get_is_absolute(*args)
_bt_ctf_clock_get_is_absolute = _babeltrace._bt_ctf_clock_get_is_absolute

def _bt_ctf_clock_set_is_absolute(*args):
  return _babeltrace._bt_ctf_clock_set_is_absolute(*args)
_bt_ctf_clock_set_is_absolute = _babeltrace._bt_ctf_clock_set_is_absolute

def _bt_ctf_clock_get_time(*args):
  return _babeltrace._bt_ctf_clock_get_time(*args)
_bt_ctf_clock_get_time = _babeltrace._bt_ctf_clock_get_time

def _bt_ctf_clock_set_time(*args):
  return _babeltrace._bt_ctf_clock_set_time(*args)
_bt_ctf_clock_set_time = _babeltrace._bt_ctf_clock_set_time

def _bt_ctf_clock_get(*args):
  return _babeltrace._bt_ctf_clock_get(*args)
_bt_ctf_clock_get = _babeltrace._bt_ctf_clock_get

def _bt_ctf_clock_put(*args):
  return _babeltrace._bt_ctf_clock_put(*args)
_bt_ctf_clock_put = _babeltrace._bt_ctf_clock_put

def _bt_ctf_field_type_integer_create(*args):
  return _babeltrace._bt_ctf_field_type_integer_create(*args)
_bt_ctf_field_type_integer_create = _babeltrace._bt_ctf_field_type_integer_create

def _bt_ctf_field_type_integer_get_size(*args):
  return _babeltrace._bt_ctf_field_type_integer_get_size(*args)
_bt_ctf_field_type_integer_get_size = _babeltrace._bt_ctf_field_type_integer_get_size

def _bt_ctf_field_type_integer_get_signed(*args):
  return _babeltrace._bt_ctf_field_type_integer_get_signed(*args)
_bt_ctf_field_type_integer_get_signed = _babeltrace._bt_ctf_field_type_integer_get_signed

def _bt_ctf_field_type_integer_set_signed(*args):
  return _babeltrace._bt_ctf_field_type_integer_set_signed(*args)
_bt_ctf_field_type_integer_set_signed = _babeltrace._bt_ctf_field_type_integer_set_signed

def _bt_ctf_field_type_integer_get_base(*args):
  return _babeltrace._bt_ctf_field_type_integer_get_base(*args)
_bt_ctf_field_type_integer_get_base = _babeltrace._bt_ctf_field_type_integer_get_base

def _bt_ctf_field_type_integer_set_base(*args):
  return _babeltrace._bt_ctf_field_type_integer_set_base(*args)
_bt_ctf_field_type_integer_set_base = _babeltrace._bt_ctf_field_type_integer_set_base

def _bt_ctf_field_type_integer_get_encoding(*args):
  return _babeltrace._bt_ctf_field_type_integer_get_encoding(*args)
_bt_ctf_field_type_integer_get_encoding = _babeltrace._bt_ctf_field_type_integer_get_encoding

def _bt_ctf_field_type_integer_set_encoding(*args):
  return _babeltrace._bt_ctf_field_type_integer_set_encoding(*args)
_bt_ctf_field_type_integer_set_encoding = _babeltrace._bt_ctf_field_type_integer_set_encoding

def _bt_ctf_field_type_enumeration_create(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_create(*args)
_bt_ctf_field_type_enumeration_create = _babeltrace._bt_ctf_field_type_enumeration_create

def _bt_ctf_field_type_enumeration_get_container_type(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_container_type(*args)
_bt_ctf_field_type_enumeration_get_container_type = _babeltrace._bt_ctf_field_type_enumeration_get_container_type

def _bt_ctf_field_type_enumeration_add_mapping(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_add_mapping(*args)
_bt_ctf_field_type_enumeration_add_mapping = _babeltrace._bt_ctf_field_type_enumeration_add_mapping

def _bt_ctf_field_type_enumeration_add_mapping_unsigned(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_add_mapping_unsigned(*args)
_bt_ctf_field_type_enumeration_add_mapping_unsigned = _babeltrace._bt_ctf_field_type_enumeration_add_mapping_unsigned

def _bt_ctf_field_type_enumeration_get_mapping_count(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping_count(*args)
_bt_ctf_field_type_enumeration_get_mapping_count = _babeltrace._bt_ctf_field_type_enumeration_get_mapping_count

def _bt_ctf_field_type_enumeration_get_mapping(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping(*args)
_bt_ctf_field_type_enumeration_get_mapping = _babeltrace._bt_ctf_field_type_enumeration_get_mapping

def _bt_ctf_field_type_enumeration_get_mapping_unsigned(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping_unsigned(*args)
_bt_ctf_field_type_enumeration_get_mapping_unsigned = _babeltrace._bt_ctf_field_type_enumeration_get_mapping_unsigned

def _bt_ctf_field_type_enumeration_get_mapping_index_by_name(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_name(*args)
_bt_ctf_field_type_enumeration_get_mapping_index_by_name = _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_name

def _bt_ctf_field_type_enumeration_get_mapping_index_by_value(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_value(*args)
_bt_ctf_field_type_enumeration_get_mapping_index_by_value = _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_value

def _bt_ctf_field_type_enumeration_get_mapping_index_by_unsigned_value(*args):
  return _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_unsigned_value(*args)
_bt_ctf_field_type_enumeration_get_mapping_index_by_unsigned_value = _babeltrace._bt_ctf_field_type_enumeration_get_mapping_index_by_unsigned_value

def _bt_ctf_field_type_floating_point_create():
  return _babeltrace._bt_ctf_field_type_floating_point_create()
_bt_ctf_field_type_floating_point_create = _babeltrace._bt_ctf_field_type_floating_point_create

def _bt_ctf_field_type_floating_point_get_exponent_digits(*args):
  return _babeltrace._bt_ctf_field_type_floating_point_get_exponent_digits(*args)
_bt_ctf_field_type_floating_point_get_exponent_digits = _babeltrace._bt_ctf_field_type_floating_point_get_exponent_digits

def _bt_ctf_field_type_floating_point_set_exponent_digits(*args):
  return _babeltrace._bt_ctf_field_type_floating_point_set_exponent_digits(*args)
_bt_ctf_field_type_floating_point_set_exponent_digits = _babeltrace._bt_ctf_field_type_floating_point_set_exponent_digits

def _bt_ctf_field_type_floating_point_get_mantissa_digits(*args):
  return _babeltrace._bt_ctf_field_type_floating_point_get_mantissa_digits(*args)
_bt_ctf_field_type_floating_point_get_mantissa_digits = _babeltrace._bt_ctf_field_type_floating_point_get_mantissa_digits

def _bt_ctf_field_type_floating_point_set_mantissa_digits(*args):
  return _babeltrace._bt_ctf_field_type_floating_point_set_mantissa_digits(*args)
_bt_ctf_field_type_floating_point_set_mantissa_digits = _babeltrace._bt_ctf_field_type_floating_point_set_mantissa_digits

def _bt_ctf_field_type_structure_create():
  return _babeltrace._bt_ctf_field_type_structure_create()
_bt_ctf_field_type_structure_create = _babeltrace._bt_ctf_field_type_structure_create

def _bt_ctf_field_type_structure_add_field(*args):
  return _babeltrace._bt_ctf_field_type_structure_add_field(*args)
_bt_ctf_field_type_structure_add_field = _babeltrace._bt_ctf_field_type_structure_add_field

def _bt_ctf_field_type_structure_get_field_count(*args):
  return _babeltrace._bt_ctf_field_type_structure_get_field_count(*args)
_bt_ctf_field_type_structure_get_field_count = _babeltrace._bt_ctf_field_type_structure_get_field_count

def _bt_ctf_field_type_structure_get_field(*args):
  return _babeltrace._bt_ctf_field_type_structure_get_field(*args)
_bt_ctf_field_type_structure_get_field = _babeltrace._bt_ctf_field_type_structure_get_field

def _bt_ctf_field_type_structure_get_field_type_by_name(*args):
  return _babeltrace._bt_ctf_field_type_structure_get_field_type_by_name(*args)
_bt_ctf_field_type_structure_get_field_type_by_name = _babeltrace._bt_ctf_field_type_structure_get_field_type_by_name

def _bt_ctf_field_type_variant_create(*args):
  return _babeltrace._bt_ctf_field_type_variant_create(*args)
_bt_ctf_field_type_variant_create = _babeltrace._bt_ctf_field_type_variant_create

def _bt_ctf_field_type_variant_get_tag_type(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_tag_type(*args)
_bt_ctf_field_type_variant_get_tag_type = _babeltrace._bt_ctf_field_type_variant_get_tag_type

def _bt_ctf_field_type_variant_get_tag_name(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_tag_name(*args)
_bt_ctf_field_type_variant_get_tag_name = _babeltrace._bt_ctf_field_type_variant_get_tag_name

def _bt_ctf_field_type_variant_add_field(*args):
  return _babeltrace._bt_ctf_field_type_variant_add_field(*args)
_bt_ctf_field_type_variant_add_field = _babeltrace._bt_ctf_field_type_variant_add_field

def _bt_ctf_field_type_variant_get_field_type_by_name(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_field_type_by_name(*args)
_bt_ctf_field_type_variant_get_field_type_by_name = _babeltrace._bt_ctf_field_type_variant_get_field_type_by_name

def _bt_ctf_field_type_variant_get_field_type_from_tag(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_field_type_from_tag(*args)
_bt_ctf_field_type_variant_get_field_type_from_tag = _babeltrace._bt_ctf_field_type_variant_get_field_type_from_tag

def _bt_ctf_field_type_variant_get_field_count(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_field_count(*args)
_bt_ctf_field_type_variant_get_field_count = _babeltrace._bt_ctf_field_type_variant_get_field_count

def _bt_ctf_field_type_variant_get_field(*args):
  return _babeltrace._bt_ctf_field_type_variant_get_field(*args)
_bt_ctf_field_type_variant_get_field = _babeltrace._bt_ctf_field_type_variant_get_field

def _bt_ctf_field_type_array_create(*args):
  return _babeltrace._bt_ctf_field_type_array_create(*args)
_bt_ctf_field_type_array_create = _babeltrace._bt_ctf_field_type_array_create

def _bt_ctf_field_type_array_get_element_type(*args):
  return _babeltrace._bt_ctf_field_type_array_get_element_type(*args)
_bt_ctf_field_type_array_get_element_type = _babeltrace._bt_ctf_field_type_array_get_element_type

def _bt_ctf_field_type_array_get_length(*args):
  return _babeltrace._bt_ctf_field_type_array_get_length(*args)
_bt_ctf_field_type_array_get_length = _babeltrace._bt_ctf_field_type_array_get_length

def _bt_ctf_field_type_sequence_create(*args):
  return _babeltrace._bt_ctf_field_type_sequence_create(*args)
_bt_ctf_field_type_sequence_create = _babeltrace._bt_ctf_field_type_sequence_create

def _bt_ctf_field_type_sequence_get_element_type(*args):
  return _babeltrace._bt_ctf_field_type_sequence_get_element_type(*args)
_bt_ctf_field_type_sequence_get_element_type = _babeltrace._bt_ctf_field_type_sequence_get_element_type

def _bt_ctf_field_type_sequence_get_length_field_name(*args):
  return _babeltrace._bt_ctf_field_type_sequence_get_length_field_name(*args)
_bt_ctf_field_type_sequence_get_length_field_name = _babeltrace._bt_ctf_field_type_sequence_get_length_field_name

def _bt_ctf_field_type_string_create():
  return _babeltrace._bt_ctf_field_type_string_create()
_bt_ctf_field_type_string_create = _babeltrace._bt_ctf_field_type_string_create

def _bt_ctf_field_type_string_get_encoding(*args):
  return _babeltrace._bt_ctf_field_type_string_get_encoding(*args)
_bt_ctf_field_type_string_get_encoding = _babeltrace._bt_ctf_field_type_string_get_encoding

def _bt_ctf_field_type_string_set_encoding(*args):
  return _babeltrace._bt_ctf_field_type_string_set_encoding(*args)
_bt_ctf_field_type_string_set_encoding = _babeltrace._bt_ctf_field_type_string_set_encoding

def _bt_ctf_field_type_get_alignment(*args):
  return _babeltrace._bt_ctf_field_type_get_alignment(*args)
_bt_ctf_field_type_get_alignment = _babeltrace._bt_ctf_field_type_get_alignment

def _bt_ctf_field_type_set_alignment(*args):
  return _babeltrace._bt_ctf_field_type_set_alignment(*args)
_bt_ctf_field_type_set_alignment = _babeltrace._bt_ctf_field_type_set_alignment

def _bt_ctf_field_type_get_byte_order(*args):
  return _babeltrace._bt_ctf_field_type_get_byte_order(*args)
_bt_ctf_field_type_get_byte_order = _babeltrace._bt_ctf_field_type_get_byte_order

def _bt_ctf_field_type_set_byte_order(*args):
  return _babeltrace._bt_ctf_field_type_set_byte_order(*args)
_bt_ctf_field_type_set_byte_order = _babeltrace._bt_ctf_field_type_set_byte_order

def _bt_ctf_field_type_get_type_id(*args):
  return _babeltrace._bt_ctf_field_type_get_type_id(*args)
_bt_ctf_field_type_get_type_id = _babeltrace._bt_ctf_field_type_get_type_id

def _bt_ctf_field_type_get(*args):
  return _babeltrace._bt_ctf_field_type_get(*args)
_bt_ctf_field_type_get = _babeltrace._bt_ctf_field_type_get

def _bt_ctf_field_type_put(*args):
  return _babeltrace._bt_ctf_field_type_put(*args)
_bt_ctf_field_type_put = _babeltrace._bt_ctf_field_type_put

def _bt_ctf_field_create(*args):
  return _babeltrace._bt_ctf_field_create(*args)
_bt_ctf_field_create = _babeltrace._bt_ctf_field_create

def _bt_ctf_field_structure_get_field(*args):
  return _babeltrace._bt_ctf_field_structure_get_field(*args)
_bt_ctf_field_structure_get_field = _babeltrace._bt_ctf_field_structure_get_field

def _bt_ctf_field_array_get_field(*args):
  return _babeltrace._bt_ctf_field_array_get_field(*args)
_bt_ctf_field_array_get_field = _babeltrace._bt_ctf_field_array_get_field

def _bt_ctf_field_sequence_get_length(*args):
  return _babeltrace._bt_ctf_field_sequence_get_length(*args)
_bt_ctf_field_sequence_get_length = _babeltrace._bt_ctf_field_sequence_get_length

def _bt_ctf_field_sequence_set_length(*args):
  return _babeltrace._bt_ctf_field_sequence_set_length(*args)
_bt_ctf_field_sequence_set_length = _babeltrace._bt_ctf_field_sequence_set_length

def _bt_ctf_field_sequence_get_field(*args):
  return _babeltrace._bt_ctf_field_sequence_get_field(*args)
_bt_ctf_field_sequence_get_field = _babeltrace._bt_ctf_field_sequence_get_field

def _bt_ctf_field_variant_get_field(*args):
  return _babeltrace._bt_ctf_field_variant_get_field(*args)
_bt_ctf_field_variant_get_field = _babeltrace._bt_ctf_field_variant_get_field

def _bt_ctf_field_enumeration_get_container(*args):
  return _babeltrace._bt_ctf_field_enumeration_get_container(*args)
_bt_ctf_field_enumeration_get_container = _babeltrace._bt_ctf_field_enumeration_get_container

def _bt_ctf_field_enumeration_get_mapping_name(*args):
  return _babeltrace._bt_ctf_field_enumeration_get_mapping_name(*args)
_bt_ctf_field_enumeration_get_mapping_name = _babeltrace._bt_ctf_field_enumeration_get_mapping_name

def _bt_ctf_field_signed_integer_get_value(*args):
  return _babeltrace._bt_ctf_field_signed_integer_get_value(*args)
_bt_ctf_field_signed_integer_get_value = _babeltrace._bt_ctf_field_signed_integer_get_value

def _bt_ctf_field_signed_integer_set_value(*args):
  return _babeltrace._bt_ctf_field_signed_integer_set_value(*args)
_bt_ctf_field_signed_integer_set_value = _babeltrace._bt_ctf_field_signed_integer_set_value

def _bt_ctf_field_unsigned_integer_get_value(*args):
  return _babeltrace._bt_ctf_field_unsigned_integer_get_value(*args)
_bt_ctf_field_unsigned_integer_get_value = _babeltrace._bt_ctf_field_unsigned_integer_get_value

def _bt_ctf_field_unsigned_integer_set_value(*args):
  return _babeltrace._bt_ctf_field_unsigned_integer_set_value(*args)
_bt_ctf_field_unsigned_integer_set_value = _babeltrace._bt_ctf_field_unsigned_integer_set_value

def _bt_ctf_field_floating_point_get_value(*args):
  return _babeltrace._bt_ctf_field_floating_point_get_value(*args)
_bt_ctf_field_floating_point_get_value = _babeltrace._bt_ctf_field_floating_point_get_value

def _bt_ctf_field_floating_point_set_value(*args):
  return _babeltrace._bt_ctf_field_floating_point_set_value(*args)
_bt_ctf_field_floating_point_set_value = _babeltrace._bt_ctf_field_floating_point_set_value

def _bt_ctf_field_string_get_value(*args):
  return _babeltrace._bt_ctf_field_string_get_value(*args)
_bt_ctf_field_string_get_value = _babeltrace._bt_ctf_field_string_get_value

def _bt_ctf_field_string_set_value(*args):
  return _babeltrace._bt_ctf_field_string_set_value(*args)
_bt_ctf_field_string_set_value = _babeltrace._bt_ctf_field_string_set_value

def _bt_ctf_field_get_type(*args):
  return _babeltrace._bt_ctf_field_get_type(*args)
_bt_ctf_field_get_type = _babeltrace._bt_ctf_field_get_type

def _bt_ctf_field_get(*args):
  return _babeltrace._bt_ctf_field_get(*args)
_bt_ctf_field_get = _babeltrace._bt_ctf_field_get

def _bt_ctf_field_put(*args):
  return _babeltrace._bt_ctf_field_put(*args)
_bt_ctf_field_put = _babeltrace._bt_ctf_field_put

def _bt_ctf_event_class_create(*args):
  return _babeltrace._bt_ctf_event_class_create(*args)
_bt_ctf_event_class_create = _babeltrace._bt_ctf_event_class_create

def _bt_ctf_event_class_get_name(*args):
  return _babeltrace._bt_ctf_event_class_get_name(*args)
_bt_ctf_event_class_get_name = _babeltrace._bt_ctf_event_class_get_name

def _bt_ctf_event_class_get_id(*args):
  return _babeltrace._bt_ctf_event_class_get_id(*args)
_bt_ctf_event_class_get_id = _babeltrace._bt_ctf_event_class_get_id

def _bt_ctf_event_class_set_id(*args):
  return _babeltrace._bt_ctf_event_class_set_id(*args)
_bt_ctf_event_class_set_id = _babeltrace._bt_ctf_event_class_set_id

def _bt_ctf_event_class_get_stream_class(*args):
  return _babeltrace._bt_ctf_event_class_get_stream_class(*args)
_bt_ctf_event_class_get_stream_class = _babeltrace._bt_ctf_event_class_get_stream_class

def _bt_ctf_event_class_add_field(*args):
  return _babeltrace._bt_ctf_event_class_add_field(*args)
_bt_ctf_event_class_add_field = _babeltrace._bt_ctf_event_class_add_field

def _bt_ctf_event_class_get_field_count(*args):
  return _babeltrace._bt_ctf_event_class_get_field_count(*args)
_bt_ctf_event_class_get_field_count = _babeltrace._bt_ctf_event_class_get_field_count

def _bt_ctf_event_class_get_field(*args):
  return _babeltrace._bt_ctf_event_class_get_field(*args)
_bt_ctf_event_class_get_field = _babeltrace._bt_ctf_event_class_get_field

def _bt_ctf_event_class_get_field_by_name(*args):
  return _babeltrace._bt_ctf_event_class_get_field_by_name(*args)
_bt_ctf_event_class_get_field_by_name = _babeltrace._bt_ctf_event_class_get_field_by_name

def _bt_ctf_event_class_get(*args):
  return _babeltrace._bt_ctf_event_class_get(*args)
_bt_ctf_event_class_get = _babeltrace._bt_ctf_event_class_get

def _bt_ctf_event_class_put(*args):
  return _babeltrace._bt_ctf_event_class_put(*args)
_bt_ctf_event_class_put = _babeltrace._bt_ctf_event_class_put

def _bt_ctf_event_create(*args):
  return _babeltrace._bt_ctf_event_create(*args)
_bt_ctf_event_create = _babeltrace._bt_ctf_event_create

def _bt_ctf_event_get_class(*args):
  return _babeltrace._bt_ctf_event_get_class(*args)
_bt_ctf_event_get_class = _babeltrace._bt_ctf_event_get_class

def _bt_ctf_event_get_clock(*args):
  return _babeltrace._bt_ctf_event_get_clock(*args)
_bt_ctf_event_get_clock = _babeltrace._bt_ctf_event_get_clock

def _bt_ctf_event_get_payload(*args):
  return _babeltrace._bt_ctf_event_get_payload(*args)
_bt_ctf_event_get_payload = _babeltrace._bt_ctf_event_get_payload

def _bt_ctf_event_set_payload(*args):
  return _babeltrace._bt_ctf_event_set_payload(*args)
_bt_ctf_event_set_payload = _babeltrace._bt_ctf_event_set_payload

def _bt_ctf_event_get_payload_by_index(*args):
  return _babeltrace._bt_ctf_event_get_payload_by_index(*args)
_bt_ctf_event_get_payload_by_index = _babeltrace._bt_ctf_event_get_payload_by_index

def _bt_ctf_event_get(*args):
  return _babeltrace._bt_ctf_event_get(*args)
_bt_ctf_event_get = _babeltrace._bt_ctf_event_get

def _bt_ctf_event_put(*args):
  return _babeltrace._bt_ctf_event_put(*args)
_bt_ctf_event_put = _babeltrace._bt_ctf_event_put

def _bt_ctf_stream_class_create(*args):
  return _babeltrace._bt_ctf_stream_class_create(*args)
_bt_ctf_stream_class_create = _babeltrace._bt_ctf_stream_class_create

def _bt_ctf_stream_class_get_name(*args):
  return _babeltrace._bt_ctf_stream_class_get_name(*args)
_bt_ctf_stream_class_get_name = _babeltrace._bt_ctf_stream_class_get_name

def _bt_ctf_stream_class_get_clock(*args):
  return _babeltrace._bt_ctf_stream_class_get_clock(*args)
_bt_ctf_stream_class_get_clock = _babeltrace._bt_ctf_stream_class_get_clock

def _bt_ctf_stream_class_set_clock(*args):
  return _babeltrace._bt_ctf_stream_class_set_clock(*args)
_bt_ctf_stream_class_set_clock = _babeltrace._bt_ctf_stream_class_set_clock

def _bt_ctf_stream_class_get_id(*args):
  return _babeltrace._bt_ctf_stream_class_get_id(*args)
_bt_ctf_stream_class_get_id = _babeltrace._bt_ctf_stream_class_get_id

def _bt_ctf_stream_class_set_id(*args):
  return _babeltrace._bt_ctf_stream_class_set_id(*args)
_bt_ctf_stream_class_set_id = _babeltrace._bt_ctf_stream_class_set_id

def _bt_ctf_stream_class_add_event_class(*args):
  return _babeltrace._bt_ctf_stream_class_add_event_class(*args)
_bt_ctf_stream_class_add_event_class = _babeltrace._bt_ctf_stream_class_add_event_class

def _bt_ctf_stream_class_get_event_class_count(*args):
  return _babeltrace._bt_ctf_stream_class_get_event_class_count(*args)
_bt_ctf_stream_class_get_event_class_count = _babeltrace._bt_ctf_stream_class_get_event_class_count

def _bt_ctf_stream_class_get_event_class(*args):
  return _babeltrace._bt_ctf_stream_class_get_event_class(*args)
_bt_ctf_stream_class_get_event_class = _babeltrace._bt_ctf_stream_class_get_event_class

def _bt_ctf_stream_class_get_event_class_by_name(*args):
  return _babeltrace._bt_ctf_stream_class_get_event_class_by_name(*args)
_bt_ctf_stream_class_get_event_class_by_name = _babeltrace._bt_ctf_stream_class_get_event_class_by_name

def _bt_ctf_stream_class_get(*args):
  return _babeltrace._bt_ctf_stream_class_get(*args)
_bt_ctf_stream_class_get = _babeltrace._bt_ctf_stream_class_get

def _bt_ctf_stream_class_put(*args):
  return _babeltrace._bt_ctf_stream_class_put(*args)
_bt_ctf_stream_class_put = _babeltrace._bt_ctf_stream_class_put

def _bt_ctf_stream_get_discarded_events_count(*args):
  return _babeltrace._bt_ctf_stream_get_discarded_events_count(*args)
_bt_ctf_stream_get_discarded_events_count = _babeltrace._bt_ctf_stream_get_discarded_events_count

def _bt_ctf_stream_append_discarded_events(*args):
  return _babeltrace._bt_ctf_stream_append_discarded_events(*args)
_bt_ctf_stream_append_discarded_events = _babeltrace._bt_ctf_stream_append_discarded_events

def _bt_ctf_stream_append_event(*args):
  return _babeltrace._bt_ctf_stream_append_event(*args)
_bt_ctf_stream_append_event = _babeltrace._bt_ctf_stream_append_event

def _bt_ctf_stream_flush(*args):
  return _babeltrace._bt_ctf_stream_flush(*args)
_bt_ctf_stream_flush = _babeltrace._bt_ctf_stream_flush

def _bt_ctf_stream_get(*args):
  return _babeltrace._bt_ctf_stream_get(*args)
_bt_ctf_stream_get = _babeltrace._bt_ctf_stream_get

def _bt_ctf_stream_put(*args):
  return _babeltrace._bt_ctf_stream_put(*args)
_bt_ctf_stream_put = _babeltrace._bt_ctf_stream_put

def _bt_ctf_writer_create(*args):
  return _babeltrace._bt_ctf_writer_create(*args)
_bt_ctf_writer_create = _babeltrace._bt_ctf_writer_create

def _bt_ctf_writer_create_stream(*args):
  return _babeltrace._bt_ctf_writer_create_stream(*args)
_bt_ctf_writer_create_stream = _babeltrace._bt_ctf_writer_create_stream

def _bt_ctf_writer_add_environment_field(*args):
  return _babeltrace._bt_ctf_writer_add_environment_field(*args)
_bt_ctf_writer_add_environment_field = _babeltrace._bt_ctf_writer_add_environment_field

def _bt_ctf_writer_add_clock(*args):
  return _babeltrace._bt_ctf_writer_add_clock(*args)
_bt_ctf_writer_add_clock = _babeltrace._bt_ctf_writer_add_clock

def _bt_ctf_writer_get_metadata_string(*args):
  return _babeltrace._bt_ctf_writer_get_metadata_string(*args)
_bt_ctf_writer_get_metadata_string = _babeltrace._bt_ctf_writer_get_metadata_string

def _bt_ctf_writer_flush_metadata(*args):
  return _babeltrace._bt_ctf_writer_flush_metadata(*args)
_bt_ctf_writer_flush_metadata = _babeltrace._bt_ctf_writer_flush_metadata

def _bt_ctf_writer_set_byte_order(*args):
  return _babeltrace._bt_ctf_writer_set_byte_order(*args)
_bt_ctf_writer_set_byte_order = _babeltrace._bt_ctf_writer_set_byte_order

def _bt_ctf_writer_get(*args):
  return _babeltrace._bt_ctf_writer_get(*args)
_bt_ctf_writer_get = _babeltrace._bt_ctf_writer_get

def _bt_ctf_writer_put(*args):
  return _babeltrace._bt_ctf_writer_put(*args)
_bt_ctf_writer_put = _babeltrace._bt_ctf_writer_put
class CTFWriter:
	# Used to compare to -1ULL in error checks
	_MAX_UINT64 = 0xFFFFFFFFFFFFFFFF

	"""
	Enumeration mapping class. start and end values are inclusive.
	"""
	class EnumerationMapping:
		def __init__(self, name, start, end):
			self.name = name
			self.start = start
			self.end = end

	class Clock:
		def __init__(self, name):
			self._c = _bt_ctf_clock_create(name)
			if self._c is None:
				raise ValueError("Invalid clock name.")

		def __del__(self):
			_bt_ctf_clock_put(self._c)

		"""
		Get the clock's name.
		"""
		@property
		def name(self):
			name = _bt_ctf_clock_get_name(self._c)
			if name is None:
				raise ValueError("Invalid clock instance.")
			return name

		"""
		Get the clock's description. None if unset.
		"""
		@property
		def description(self):
			return _bt_ctf_clock_get_description(self._c)

		"""
		Set the clock's description. The description appears in the clock's TSDL
		meta-data.
		"""
		@description.setter
		def description(self, desc):
			ret = _bt_ctf_clock_set_description(self._c, str(desc))
			if ret < 0:
				raise ValueError("Invalid clock description.")

		"""
		Get the clock's frequency (Hz).
		"""
		@property
		def frequency(self):
			freq = _bt_ctf_clock_get_frequency(self._c)
			if freq == CTFWriter._MAX_UINT64:
				raise ValueError("Invalid clock instance")
			return freq

		"""
		Set the clock's frequency (Hz).
		"""
		@frequency.setter
		def frequency(self, freq):
			ret = _bt_ctf_clock_set_frequency(self._c, freq)
			if ret < 0:
				raise ValueError("Invalid frequency value.")

		"""
		Get the clock's precision (in clock ticks).
		"""
		@property
		def precision(self):
			precision = _bt_ctf_clock_get_precision(self._c)
			if precision == CTFWriter._MAX_UINT64:
				raise ValueError("Invalid clock instance")
			return precision

		"""
		Set the clock's precision (in clock ticks).
		"""
		@precision.setter
		def precision(self, precision):
			ret = _bt_ctf_clock_set_precision(self._c, precision)

		"""
		Get the clock's offset in seconds from POSIX.1 Epoch.
		"""
		@property
		def offset_seconds(self):
			offset_s = _bt_ctf_clock_get_offset_s(self._c)
			if offset_s == CTFWriter._MAX_UINT64:
				raise ValueError("Invalid clock instance")
			return offset_s

		"""
		Set the clock's offset in seconds from POSIX.1 Epoch.
		"""
		@offset_seconds.setter
		def offset_seconds(self, offset_s):
			ret = _bt_ctf_clock_set_offset_s(self._c, offset_s)
			if ret < 0:
				raise ValueError("Invalid offset value.")

		"""
		Get the clock's offset in ticks from POSIX.1 Epoch + offset in seconds.
		"""
		@property
		def offset(self):
			offset = _bt_ctf_clock_get_offset(self._c)
			if offset == CTFWriter._MAX_UINT64:
				raise ValueError("Invalid clock instance")
			return offset

		"""
		Set the clock's offset in ticks from POSIX.1 Epoch + offset in seconds.
		"""
		@offset.setter
		def offset(self, offset):
			ret = _bt_ctf_clock_set_offset(self._c, offset)
			if ret < 0:
				raise ValueError("Invalid offset value.")

		"""
		Get a clock's absolute attribute. A clock is absolute if the clock
		is a global reference across the trace's other clocks.
		"""
		@property
		def absolute(self):
			is_absolute = _bt_ctf_clock_get_is_absolute(self._c)
			if is_absolute == -1:
				raise ValueError("Invalid clock instance")
			return False if is_absolute == 0 else True

		"""
		Set a clock's absolute attribute. A clock is absolute if the clock
		is a global reference across the trace's other clocks.
		"""
		@absolute.setter
		def absolute(self, is_absolute):
			ret = _bt_ctf_clock_set_is_absolute(self._c, int(is_absolute))
			if ret < 0:
				raise ValueError("Could not set the clock's absolute attribute.")

		"""
		Get the current time in nanoseconds since the clock's origin (offset and
		offset_s attributes).
		"""
		@property
		def time(self):
			time = _bt_ctf_clock_get_time(self._c)
			if time == CTFWriter._MAX_UINT64:
				raise ValueError("Invalid clock instance")
			return time

		"""
		Set the current time in nanoseconds since the clock's origin (offset and
		offset_s attributes). The clock's value will be sampled as events are
		appended to a stream.
		"""
		@time.setter
		def time(self, time):
			ret = _bt_ctf_clock_set_time(self._c, time)
			if ret < 0:
				raise ValueError("Invalid time value.")

	class FieldDeclaration:
		"""
		FieldDeclaration should not be instantiated directly. Instantiate
		one of the concrete FieldDeclaration classes.
		"""
		class IntegerBase:
			# These values are based on the bt_ctf_integer_base enum
			# declared in event-types.h.
			INTEGER_BASE_UNKNOWN = -1
			INTEGER_BASE_BINARY = 2
			INTEGER_BASE_OCTAL = 8
			INTEGER_BASE_DECIMAL = 10
			INTEGER_BASE_HEXADECIMAL = 16

		def __init__(self):
			if self._ft is None:
				raise ValueError("FieldDeclaration creation failed.")

		def __del__(self):
			_bt_ctf_field_type_put(self._ft)

		@staticmethod
		def _create_field_declaration_from_native_instance(native_field_declaration):
			type_dict = {
				CTFTypeId.INTEGER : CTFWriter.IntegerFieldDeclaration,
				CTFTypeId.FLOAT : CTFWriter.FloatFieldDeclaration,
				CTFTypeId.ENUM : CTFWriter.EnumerationFieldDeclaration,
				CTFTypeId.STRING : CTFWriter.StringFieldDeclaration,
				CTFTypeId.STRUCT : CTFWriter.StructureFieldDeclaration,
				CTFTypeId.VARIANT : CTFWriter.VariantFieldDeclaration,
				CTFTypeId.ARRAY : CTFWriter.ArrayFieldDeclaration,
				CTFTypeId.SEQUENCE : CTFWriter.SequenceFieldDeclaration
			}

			field_type_id = _bt_ctf_field_type_get_type_id(native_field_declaration)
			if field_type_id == CTFTypeId.UNKNOWN:
				raise TypeError("Invalid field instance")

			declaration = CTFWriter.Field.__new__(CTFWriter.Field)
			declaration._ft = native_field_declaration
			declaration.__class__ = type_dict[field_type_id]
			return declaration

		"""
		Get the field declaration's alignment. Returns -1 on error.
		"""
		@property
		def alignment(self):
			return _bt_ctf_field_type_get_alignment(self._ft)

		"""
		Set the field declaration's alignment. Defaults to 1 (bit-aligned). However,
		some types, such as structures and string, may impose other alignment
		constraints.
		"""
		@alignment.setter
		def alignment(self, alignment):
			ret = _bt_ctf_field_type_set_alignment(self._ft, alignment)
			if ret < 0:
				raise ValueError("Invalid alignment value.")

		"""
		Get the field declaration's byte order. One of the ByteOrder's constant.
		"""
		@property
		def byte_order(self):
			return _bt_ctf_field_type_get_byte_order(self._ft)

		"""
		Set the field declaration's byte order. Use constants defined in the ByteOrder
		class.
		"""
		@byte_order.setter
		def byte_order(self, byte_order):
			ret = _bt_ctf_field_type_set_byte_order(self._ft, byte_order)
			if ret < 0:
				raise ValueError("Could not set byte order value.")

	class IntegerFieldDeclaration(FieldDeclaration):
		"""
		Create a new integer field declaration of the given size.
		"""
		def __init__(self, size):
			self._ft = _bt_ctf_field_type_integer_create(size)
			super().__init__()

		"""
		Get an integer's size.
		"""
		@property
		def size(self):
			ret = _bt_ctf_field_type_integer_get_size(self._ft)
			if ret < 0:
				raise ValueError("Could not get Integer's size attribute.")
			else:
				return ret

		"""
		Get an integer's signedness attribute.
		"""
		@property
		def signed(self):
			ret = _bt_ctf_field_type_integer_get_signed(self._ft)
			if ret < 0:
				raise ValueError("Could not get Integer's signed attribute.")
			elif ret > 0:
				return True
			else:
				return False

		"""
		Set an integer's signedness attribute.
		"""
		@signed.setter
		def signed(self, signed):
			ret = _bt_ctf_field_type_integer_set_signed(self._ft, signed)
			if ret < 0:
				raise ValueError("Could not set Integer's signed attribute.")

		"""
		Get the integer's base used to pretty-print the resulting trace.
		Returns a constant from the FieldDeclaration.IntegerBase class.
		"""
		@property
		def base(self):
			return _bt_ctf_field_type_integer_get_base(self._ft)

		"""
		Set the integer's base used to pretty-print the resulting trace.
		The base must be a constant of the FieldDeclarationIntegerBase class.
		"""
		@base.setter
		def base(self, base):
			ret = _bt_ctf_field_type_integer_set_base(self._ft, base)
			if ret < 0:
				raise ValueError("Could not set Integer's base.")

		"""
		Get the integer's encoding (one of the constants of the
		CTFStringEncoding class).
		Returns a constant from the CTFStringEncoding class.
		"""
		@property
		def encoding(self):
			return _bt_ctf_field_type_integer_get_encoding(self._ft)

		"""
		An integer encoding may be set to signal that the integer must be printed
		as a text character. Must be a constant from the CTFStringEncoding class.
		"""
		@encoding.setter
		def encoding(self, encoding):
			ret = _bt_ctf_field_type_integer_set_encoding(self._ft, encoding)
			if ret < 0:
				raise ValueError("Could not set Integer's encoding.")

	class EnumerationFieldDeclaration(FieldDeclaration):
		"""
		Create a new enumeration field declaration with the given underlying container type.
		"""
		def __init__(self, integer_type):
			if integer_type is None or not isinstance(integer_type, CTFWriter.IntegerFieldDeclaration):
				raise TypeError("Invalid integer container.")

			self._ft = _bt_ctf_field_type_enumeration_create(integer_type._ft)
			super().__init__()

		"""
		Get the enumeration's underlying container type.
		"""
		@property
		def container(self):
			ret = _bt_ctf_field_type_enumeration_get_container_type(self._ft)
			if ret is None:
				raise TypeError("Invalid enumeration declaration")
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(ret)

		"""
		Add a mapping to the enumeration. The range's values are inclusive.
		"""
		def add_mapping(self, name, range_start, range_end):
			if range_start < 0 or range_end < 0:
				ret = _bt_ctf_field_type_enumeration_add_mapping(self._ft, str(name), range_start, range_end)
			else:
				ret = _bt_ctf_field_type_enumeration_add_mapping_unsigned(self._ft, str(name), range_start, range_end)

			if ret < 0:
				raise ValueError("Could not add mapping to enumeration declaration.")

		"""
		Generator returning instances of EnumerationMapping.
		"""
		@property
		def mappings(self):
			signed = self.container.signed

			count = _bt_ctf_field_type_enumeration_get_mapping_count(self._ft)
			for i in range(count):
				if signed:
					ret = _bt_python_ctf_field_type_enumeration_get_mapping(self._ft, i)
				else:
					ret = _bt_python_ctf_field_type_enumeration_get_mapping_unsigned(self._ft, i)

				if len(ret) != 3:
					raise TypeError("Could not get Enumeration mapping at index {}".format(i))
				name, range_start, range_end = ret
				yield CTFWriter.EnumerationMapping(name, range_start, range_end)

		"""
		Get a mapping by name (EnumerationMapping).
		"""
		def get_mapping_by_name(self, name):
			ret, index = _bt_ctf_field_type_enumeration_get_mapping_index_by_name(self._ft, name);
			if ret < 0:
				return None

			if self.container.signed:
				ret = _bt_python_ctf_field_type_enumeration_get_mapping(self._ft, index)
			else:
				ret = _bt_python_ctf_field_type_enumeration_get_mapping_unsigned(self._ft, index)

			if len(ret) != 3:
				raise TypeError("Could not get Enumeration mapping at index {}".format(i))
			name, range_start, range_end = ret
			return CTFWriter.EnumerationMapping(name, range_start, range_end)

		"""
		Get a mapping by value (EnumerationMapping).
		"""
		def get_mapping_by_value(self, value):
			if value < 0:
				ret, index = _bt_ctf_field_type_enumeration_get_mapping_index_by_value(self._ft, value);
			else:
				ret, index = _bt_ctf_field_type_enumeration_get_mapping_index_by_unsigned_value(self._ft, value);

			if ret < 0:
				return None

			if self.container.signed:
				ret = _bt_python_ctf_field_type_enumeration_get_mapping(self._ft, index)
			else:
				ret = _bt_python_ctf_field_type_enumeration_get_mapping_unsigned(self._ft, index)

			if len(ret) != 3:
				raise TypeError("Could not get Enumeration mapping at index {}".format(i))
			name, range_start, range_end = ret
			return CTFWriter.EnumerationMapping(name, range_start, range_end)

	class FloatFieldDeclaration(FieldDeclaration):
		FLT_EXP_DIG = 8
		DBL_EXP_DIG = 11
		FLT_MANT_DIG = 24
		DBL_MANT_DIG = 53

		"""
		Create a new floating point field declaration.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_floating_point_create()
			super().__init__()

		"""
		Get the number of exponent digits used to store the floating point field.
		"""
		@property
		def exponent_digits(self):
			ret = _bt_ctf_field_type_floating_point_get_exponent_digits(self._ft)
			if ret < 0:
				raise TypeError("Could not get Floating point exponent digit count")
			return ret

		"""
		Set the number of exponent digits to use to store the floating point field.
		The only values currently supported are FLT_EXP_DIG and DBL_EXP_DIG which
		are defined as constants of this class.
		"""
		@exponent_digits.setter
		def exponent_digits(self, exponent_digits):
			ret = _bt_ctf_field_type_floating_point_set_exponent_digits(self._ft, exponent_digits)
			if ret < 0:
				raise ValueError("Could not set exponent digit count.")

		"""
		Get the number of mantissa digits used to store the floating point field.
		"""
		@property
		def mantissa_digits(self):
			ret = _bt_ctf_field_type_floating_point_get_mantissa_digits(self._ft)
			if ret < 0:
				raise TypeError("Could not get Floating point mantissa digit count")
			return ret

		"""
		Set the number of mantissa digits to use to store the floating point field.
		The only values currently supported are FLT_MANT_DIG and DBL_MANT_DIG which
		are defined as constants of this class.
		"""
		@mantissa_digits.setter
		def mantissa_digits(self, mantissa_digits):
			ret = _bt_ctf_field_type_floating_point_set_mantissa_digits(self._ft, mantissa_digits)
			if ret < 0:
				raise ValueError("Could not set mantissa digit count.")

	class StructureFieldDeclaration(FieldDeclaration):
		"""
		Create a new structure field declaration.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_structure_create()
			super().__init__()

		"""
		Add a field of type "field_type" to the structure.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_field_type_structure_add_field(self._ft, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to structure.")

		"""
		Generator returning the structure's field as tuples of (field name, field declaration).
		"""
		@property
		def fields(self):
			count = _bt_ctf_field_type_structure_get_field_count(self._ft)
			if count < 0:
				raise TypeError("Could not get Structure field count")

			for i in range(count):
				field_name = _bt_python_ctf_field_type_structure_get_field_name(self._ft, i)
				if field_name is None:
					raise TypeError("Could not get Structure field name at index {}".format(i))

				field_type_native = _bt_python_ctf_field_type_structure_get_field_type(self._ft, i)
				if field_type_native is None:
					raise TypeError("Could not get Structure field type at index {}".format(i))

				field_type = CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)
				yield (field_name, field_type)

		"""
		Get a field declaration by name (FieldDeclaration).
		"""
		def get_field_by_name(self, name):
			field_type_native = _bt_ctf_field_type_structure_get_field_type_by_name(self._ft, name)
			if field_type_native is None:
				raise TypeError("Could not find Structure field with name {}".format(name))

			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)

	class VariantFieldDeclaration(FieldDeclaration):
		"""
		Create a new variant field declaration.
		"""
		def __init__(self, enum_tag, tag_name):
			if enum_tag is None or not isinstance(enum_tag, CTFWriter.EnumerationFieldDeclaration):
				raise TypeError("Invalid tag type; must be of type EnumerationFieldDeclaration.")

			self._ft = _bt_ctf_field_type_variant_create(enum_tag._ft, str(tag_name))
			super().__init__()

		"""
		Get the variant's tag name.
		"""
		@property
		def tag_name(self):
			ret = _bt_ctf_field_type_variant_get_tag_name(self._ft)
			if ret is None:
				raise TypeError("Could not get Variant tag name")
			return ret

		"""
		Get the variant's tag type.
		"""
		@property
		def tag_type(self):
			ret = _bt_ctf_field_type_variant_get_tag_type(self._ft)
			if ret is None:
				raise TypeError("Could not get Variant tag type")
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(ret)

		"""
		Add a field of type "field_type" to the variant.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_field_type_variant_add_field(self._ft, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to variant.")

		"""
		Generator returning the variant's field as tuples of (field name, field declaration).
		"""
		@property
		def fields(self):
			count = _bt_ctf_field_type_variant_get_field_count(self._ft)
			if count < 0:
				raise TypeError("Could not get Variant field count")

			for i in range(count):
				field_name = _bt_python_ctf_field_type_variant_get_field_name(self._ft, i)
				if field_name is None:
					raise TypeError("Could not get Variant field name at index {}".format(i))

				field_type_native = _bt_python_ctf_field_type_variant_get_field_type(self._ft, i)
				if field_type_native is None:
					raise TypeError("Could not get Variant field type at index {}".format(i))

				field_type = CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)
				yield (field_name, field_type)

		"""
		Get a field declaration by name (FieldDeclaration).
		"""
		def get_field_by_name(self, name):
			field_type_native = _bt_ctf_field_type_variant_get_field_type_by_name(self._ft, name)
			if field_type_native is None:
				raise TypeError("Could not find Variant field with name {}".format(name))

			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)

		"""
		Get a field declaration from tag (EnumerationField).
		"""
		def get_field_from_tag(self, tag):
			field_type_native = _bt_ctf_field_type_variant_get_field_type_from_tag(self._ft, tag._f)
			if field_type_native is None:
				raise TypeError("Could not find Variant field with tag value {}".format(tag.value))

			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)

	class ArrayFieldDeclaration(FieldDeclaration):
		"""
		Create a new array field declaration.
		"""
		def __init__(self, element_type, length):
			self._ft = _bt_ctf_field_type_array_create(element_type._ft, length)
			super().__init__()

		"""
		Get the array's element type.
		"""
		@property
		def element_type(self):
			ret = _bt_ctf_field_type_array_get_element_type(self._ft)
			if ret is None:
				raise TypeError("Could not get Array element type")
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(ret)

		"""
		Get the array's length.
		"""
		@property
		def length(self):
			ret = _bt_ctf_field_type_array_get_length(self._ft)
			if ret < 0:
				raise TypeError("Could not get Array length")
			return ret

	class SequenceFieldDeclaration(FieldDeclaration):
		"""
		Create a new sequence field declaration.
		"""
		def __init__(self, element_type, length_field_name):
			self._ft = _bt_ctf_field_type_sequence_create(element_type._ft, str(length_field_name))
			super().__init__()

		"""
		Get the sequence's element type.
		"""
		@property
		def element_type(self):
			ret = _bt_ctf_field_type_sequence_get_element_type(self._ft)
			if ret is None:
				raise TypeError("Could not get Sequence element type")
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(ret)

		"""
		Get the sequence's length field name.
		"""
		@property
		def length_field_name(self):
			ret = _bt_ctf_field_type_sequence_get_length_field_name(self._ft)
			if ret is None:
				raise TypeError("Could not get Sequence length field name")
			return ret

	class StringFieldDeclaration(FieldDeclaration):
		"""
		Create a new string field declaration.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_string_create()
			super().__init__()

		"""
		Get a string declaration's encoding (a constant from the CTFStringEncoding class).
		"""
		@property
		def encoding(self):
			return _bt_ctf_field_type_string_get_encoding(self._ft)

		"""
		Set a string declaration's encoding. Must be a constant from the CTFStringEncoding class.
		"""
		@encoding.setter
		def encoding(self, encoding):
			ret = _bt_ctf_field_type_string_set_encoding(self._ft, encoding)
			if ret < 0:
				raise ValueError("Could not set string encoding.")

	"""
	Create an instance of a field.
	"""
	@staticmethod
	def create_field(field_type):
		if field_type is None or not isinstance(field_type, CTFWriter.FieldDeclaration):
			raise TypeError("Invalid field_type. Type must be a FieldDeclaration-derived class.")

		if isinstance(field_type, CTFWriter.IntegerFieldDeclaration):
			return CTFWriter.IntegerField(field_type)
		elif isinstance(field_type, CTFWriter.EnumerationFieldDeclaration):
			return CTFWriter.EnumerationField(field_type)
		elif isinstance(field_type, CTFWriter.FloatFieldDeclaration):
			return CTFWriter.FloatFieldingPoint(field_type)
		elif isinstance(field_type, CTFWriter.StructureFieldDeclaration):
			return CTFWriter.StructureField(field_type)
		elif isinstance(field_type, CTFWriter.VariantFieldDeclaration):
			return CTFWriter.VariantField(field_type)
		elif isinstance(field_type, CTFWriter.ArrayFieldDeclaration):
			return CTFWriter.ArrayField(field_type)
		elif isinstance(field_type, CTFWriter.SequenceFieldDeclaration):
			return CTFWriter.SequenceField(field_type)
		elif isinstance(field_type, CTFWriter.StringFieldDeclaration):
			return CTFWriter.StringField(field_type)

	class Field:
		"""
		Base class, do not instantiate.
		"""
		def __init__(self, field_type):
			if not isinstance(field_type, CTFWriter.FieldDeclaration):
				raise TypeError("Invalid field_type argument.")

			self._f = _bt_ctf_field_create(field_type._ft)
			if self._f is None:
				raise ValueError("Field creation failed.")

		def __del__(self):
			_bt_ctf_field_put(self._f)

		@staticmethod
		def _create_field_from_native_instance(native_field_instance):
			type_dict = {
				CTFTypeId.INTEGER : CTFWriter.IntegerField,
				CTFTypeId.FLOAT : CTFWriter.FloatFieldingPoint,
				CTFTypeId.ENUM : CTFWriter.EnumerationField,
				CTFTypeId.STRING : CTFWriter.StringField,
				CTFTypeId.STRUCT : CTFWriter.StructureField,
				CTFTypeId.VARIANT : CTFWriter.VariantField,
				CTFTypeId.ARRAY : CTFWriter.ArrayField,
				CTFTypeId.SEQUENCE : CTFWriter.SequenceField
			}

			field_type = _bt_python_get_field_type(native_field_instance)
			if field_type == CTFTypeId.UNKNOWN:
				raise TypeError("Invalid field instance")

			field = CTFWriter.Field.__new__(CTFWriter.Field)
			field._f = native_field_instance
			field.__class__ = type_dict[field_type]
			return field

		@property
		def declaration(self):
			native_field_type = _bt_ctf_field_get_type(self._f)
			if native_field_type is None:
				raise TypeError("Invalid field instance")
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(native_field_type)

	class IntegerField(Field):
		"""
		Get an integer field's value.
		"""
		@property
		def value(self):
			signedness = _bt_python_field_integer_get_signedness(self._f)
			if signedness < 0:
				raise TypeError("Invalid integer instance.")

			if signedness == 0:
				ret, value = _bt_ctf_field_unsigned_integer_get_value(self._f)
			else:
				ret, value = _bt_ctf_field_signed_integer_get_value(self._f)

			if ret < 0:
				raise ValueError("Could not get integer field value.")
			return value

		"""
		Set an integer field's value.
		"""
		@value.setter
		def value(self, value):
			if not isinstance(value, int):
				raise TypeError("IntegerField's value must be an int")

			signedness = _bt_python_field_integer_get_signedness(self._f)
			if signedness < 0:
				raise TypeError("Invalid integer instance.")

			if signedness == 0:
				ret = _bt_ctf_field_unsigned_integer_set_value(self._f, value)
			else:
				ret = _bt_ctf_field_signed_integer_set_value(self._f, value)

			if ret < 0:
				raise ValueError("Could not set integer field value.")

	class EnumerationField(Field):
		"""
		Return the enumeration's underlying container field (an integer field).
		"""
		@property
		def container(self):
			container = CTFWriter.IntegerField.__new__(CTFWriter.IntegerField)
			container._f = _bt_ctf_field_enumeration_get_container(self._f)
			if container._f is None:
				raise TypeError("Invalid enumeration field type.")
			return container

		"""
		Get the enumeration field's mapping name.
		"""
		@property
		def value(self):
			value = _bt_ctf_field_enumeration_get_mapping_name(self._f)
			if value is None:
				raise ValueError("Could not get enumeration's mapping name.")
			return value

		"""
		Set the enumeration field's value. Must be an integer as mapping names
		may be ambiguous.
		"""
		@value.setter
		def value(self, value):
			if not isinstance(value, int):
				raise TypeError("EnumerationField value must be an int")
			self.container.value = value

	class FloatFieldingPoint(Field):
		"""
		Get a floating point field's value.
		"""
		@property
		def value(self):
			ret, value = _bt_ctf_field_floating_point_get_value(self._f)
			if ret < 0:
				raise ValueError("Could not get floating point field value.")
			return value

		"""
		Set a floating point field's value.
		"""
		@value.setter
		def value(self, value):
			if not isinstance(value, int) and not isinstance(value, float):
				raise TypeError("Value must be either a float or an int")

			ret = _bt_ctf_field_floating_point_set_value(self._f, float(value))
			if ret < 0:
				raise ValueError("Could not set floating point field value.")

	class StructureField(Field):
		"""
		Get the structure's field corresponding to the provided field name.
		"""
		def field(self, field_name):
			native_instance = _bt_ctf_field_structure_get_field(self._f, str(field_name))
			if native_instance is None:
				raise ValueError("Invalid field_name provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class VariantField(Field):
		"""
		Return the variant's selected field. The "tag" field is the selector enum field.
		"""
		def field(self, tag):
			native_instance = _bt_ctf_field_variant_get_field(self._f, tag._f)
			if native_instance is None:
				raise ValueError("Invalid tag provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class ArrayField(Field):
		"""
		Return the array's field at position "index".
		"""
		def field(self, index):
			native_instance = _bt_ctf_field_array_get_field(self._f, index)
			if native_instance is None:
				raise IndexError("Invalid index provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class SequenceField(Field):
		"""
		Get the sequence's length field (IntegerField).
		"""
		@property
		def length(self):
			native_instance = _bt_ctf_field_sequence_get_length(self._f)
			if native_instance is None:
				length = -1
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

		"""
		Set the sequence's length field (IntegerField).
		"""
		@length.setter
		def length(self, length_field):
			if not isinstance(length_field, CTFWriter.IntegerField):
				raise TypeError("Invalid length field.")
			if length_field.declaration.signed:
				raise TypeError("Sequence field length must be unsigned")
			ret = _bt_ctf_field_sequence_set_length(self._f, length_field._f)
			if ret < 0:
				raise ValueError("Could not set sequence length.")

		"""
		Return the sequence's field at position "index".
		"""
		def field(self, index):
			native_instance = _bt_ctf_field_sequence_get_field(self._f, index)
			if native_instance is None:
				raise ValueError("Could not get sequence element at index.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class StringField(Field):
		"""
		Get a string field's value.
		"""
		@property
		def value(self):
			return _bt_ctf_field_string_get_value(self._f)

		"""
		Set a string field's value.
		"""
		@value.setter
		def value(self, value):
			ret = _bt_ctf_field_string_set_value(self._f, str(value))
			if ret < 0:
				raise ValueError("Could not set string field value.")

	class EventClass:
		"""
		Create a new event class of the given name.
		"""
		def __init__(self, name):
			self._ec = _bt_ctf_event_class_create(name)
			if self._ec is None:
				raise ValueError("Event class creation failed.")

		def __del__(self):
			_bt_ctf_event_class_put(self._ec)

		"""
		Add a field of type "field_type" to the event class.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_event_class_add_field(self._ec, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to event class.")

		"""
		Get the event class' name.
		"""
		@property
		def name(self):
			name = _bt_ctf_event_class_get_name(self._ec)
			if name is None:
				raise TypeError("Could not get EventClass name")
			return name

		"""
		Get the event class' id. Returns a negative value if unset.
		"""
		@property
		def id(self):
			id = _bt_ctf_event_class_get_id(self._ec)
			if id < 0:
				raise TypeError("Could not get EventClass id")
			return id

		"""
		Set the event class' id. Throws a TypeError if the event class
		is already registered to a stream class.
		"""
		@id.setter
		def id(self, id):
			ret = _bt_ctf_event_class_set_id(self._ec, id)
			if ret < 0:
				raise TypeError("Can't change an Event Class's id after it has been assigned to a stream class")

		"""
		Get the event class' stream class. Returns None if unset.
		"""
		@property
		def stream_class(self):
			stream_class_native = _bt_ctf_event_class_get_stream_class(self._ec)
			if stream_class_native is None:
				return None
			stream_class = CTFWriter.StreamClass.__new__(CTFWriter.StreamClass)
			stream_class._sc = stream_class_native
			return stream_class

		"""
		Generator returning the event class' fields as tuples of (field name, field declaration).
		"""
		@property
		def fields(self):
			count = _bt_ctf_event_class_get_field_count(self._ec)
			if count < 0:
				raise TypeError("Could not get EventClass' field count")

			for i in range(count):
				field_name = _bt_python_ctf_event_class_get_field_name(self._ec, i)
				if field_name is None:
					raise TypeError("Could not get EventClass' field name at index {}".format(i))

				field_type_native = _bt_python_ctf_event_class_get_field_type(self._ec, i)
				if field_type_native is None:
					raise TypeError("Could not get EventClass' field type at index {}".format(i))

				field_type = CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)
				yield (field_name, field_type)

		"""
		Get a field declaration by name (FieldDeclaration).
		"""
		def get_field_by_name(self, name):
			field_type_native = _bt_ctf_event_class_get_field_by_name(self._ec, name)
			if field_type_native is None:
				raise TypeError("Could not find EventClass field with name {}".format(name))
			return CTFWriter.FieldDeclaration._create_field_declaration_from_native_instance(field_type_native)

	class Event:
		"""
		Create a new event of the given event class.
		"""
		def __init__(self, event_class):
			if not isinstance(event_class, CTFWriter.EventClass):
				raise TypeError("Invalid event_class argument.")

			self._e = _bt_ctf_event_create(event_class._ec)
			if self._e is None:
				raise ValueError("Event creation failed.")

		def __del__(self):
			_bt_ctf_event_put(self._e)

		"""
		Get the event's class.
		"""
		@property
		def event_class(self):
			event_class_native = _bt_ctf_event_get_class(self._e)
			if event_class_native is None:
				return None
			event_class = CTFWriter.EventClass.__new__(CTFWriter.EventClass)
			event_class._ec = event_class_native
			return event_class

		"""
		Get a clock from event. Returns None if the event's class
		is not registered to a stream class.
		"""
		def clock(self):
			clock_instance = _bt_ctf_event_get_clock(self._e)
			if clock_instance is None:
				return None
			clock = CTFWriter.Clock.__new__(CTFWriter.Clock)
			clock._c = clock_instance
			return clock

		"""
		Get a field from event.
		"""
		def payload(self, field_name):
			native_instance = _bt_ctf_event_get_payload(self._e, str(field_name))
			if native_instance is None:
				raise ValueError("Could not get event payload.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

		"""
		Set a manually created field as an event's payload.
		"""
		def set_payload(self, field_name, value_field):
			if not isinstance(value, CTFWriter.Field):
				raise TypeError("Invalid value type.")
			ret = _bt_ctf_event_set_payload(self._e, str(field_name), value_field._f)
			if ret < 0:
				raise ValueError("Could not set event field payload.")

	class StreamClass:
		"""
		Create a new stream class of the given name.
		"""
		def __init__(self, name):
			self._sc = _bt_ctf_stream_class_create(name)
			if self._sc is None:
				raise ValueError("Stream class creation failed.")

		def __del__(self):
			_bt_ctf_stream_class_put(self._sc)

		"""
		Get a stream class' name.
		"""
		@property
		def name(self):
			name = _bt_ctf_stream_class_get_name(self._sc)
			if name is None:
				raise TypeError("Could not get StreamClass name")
			return name

		"""
		Get a stream class' clock.
		"""
		@property
		def clock(self):
			clock_instance = _bt_ctf_stream_class_get_clock(self._sc)
			if clock_instance is None:
				return None
			clock = CTFWriter.Clock.__new__(CTFWriter.Clock)
			clock._c = clock_instance
			return clock

		"""
		Assign a clock to a stream class.
		"""
		@clock.setter
		def clock(self, clock):
			if not isinstance(clock, CTFWriter.Clock):
				raise TypeError("Invalid clock type.")

			ret = _bt_ctf_stream_class_set_clock(self._sc, clock._c)
			if ret < 0:
				raise ValueError("Could not set stream class clock.")

		"""
		Get a stream class' id.
		"""
		@property
		def id(self):
			ret = _bt_ctf_stream_class_get_id(self._sc)
			if ret < 0:
				raise TypeError("Could not get StreamClass id")
			return ret

		"""
		Assign an id to a stream class.
		"""
		@id.setter
		def id(self, id):
			ret = _bt_ctf_stream_class_set_id(self._sc, id)
			if ret < 0:
				raise TypeError("Could not set stream class id.")

		"""
		Generator returning the stream class' event classes.
		"""
		@property
		def event_classes(self):
			count = _bt_ctf_stream_class_get_event_class_count(self._sc)
			if count < 0:
				raise TypeError("Could not get StreamClass' event class count")

			for i in range(count):
				event_class_native = _bt_ctf_stream_class_get_event_class(self._sc, i)
				if event_class_native is None:
					raise TypeError("Could not get StreamClass' event class at index {}".format(i))

				event_class = CTFWriter.EventClass.__new__(CTFWriter.EventClass)
				event_class._ec = event_class_native
				yield event_class

		"""
		Add an event class to a stream class. New events can be added even after a
		stream has been instantiated and events have been appended. However, a stream
		will not accept events of a class that has not been registered beforehand.
		"""
		def add_event_class(self, event_class):
			if not isinstance(event_class, CTFWriter.EventClass):
				raise TypeError("Invalid event_class type.")

			ret = _bt_ctf_stream_class_add_event_class(self._sc, event_class._ec)
			if ret < 0:
				raise ValueError("Could not add event class.")

	class Stream:
		"""
		Create a stream of the given class.
		"""
		def __init__(self, stream_class):
			if not isinstance(stream_class, CTFWriter.StreamClass):
				raise TypeError("Invalid stream_class type.")

			self._s = _bt_ctf_stream_create(stream_class._sc)
			if self._s is None:
				raise ValueError("Stream creation failed.")

		def __del__(self):
			_bt_ctf_stream_put(self._s)

		"""
		Get a stream's discarded event count.
		"""
		@property
		def discarded_events(self):
			ret, count = _bt_ctf_stream_get_discarded_events_count(self._s)
			if ret < 0:
				raise ValueError("Could not get the stream's discarded events count")
			return count

		"""
		Increase the current packet's discarded event count.
		"""
		def append_discarded_events(self, event_count):
			_bt_ctf_stream_append_discarded_events(self._s, event_count)

		"""
		Append "event" to the stream's current packet. The stream's associated clock
		will be sampled during this call. The event shall not be modified after
		being appended to a stream.
		"""
		def append_event(self, event):
			ret = _bt_ctf_stream_append_event(self._s, event._e)
			if ret < 0:
				raise ValueError("Could not append event to stream.")

		"""
		The stream's current packet's events will be flushed to disk. Events
		subsequently appended to the stream will be added to a new packet.
		"""
		def flush(self):
			ret = _bt_ctf_stream_flush(self._s)
			if ret < 0:
				raise ValueError("Could not flush stream.")

	class Writer:
		"""
		Create a new writer that will produce a trace in the given path.
		"""
		def __init__(self, path):
			self._w = _bt_ctf_writer_create(path)
			if self._w is None:
				raise ValueError("Writer creation failed.")

		def __del__(self):
			_bt_ctf_writer_put(self._w)

		"""
		Create a new stream instance and register it to the writer.
		"""
		def create_stream(self, stream_class):
			if not isinstance(stream_class, CTFWriter.StreamClass):
				raise TypeError("Invalid stream_class type.")

			stream = CTFWriter.Stream.__new__(CTFWriter.Stream)
			stream._s = _bt_ctf_writer_create_stream(self._w, stream_class._sc)
			return stream

		"""
		Add an environment field to the trace.
		"""
		def add_environment_field(self, name, value):
			ret = _bt_ctf_writer_add_environment_field(self._w, str(name), str(value))
			if ret < 0:
				raise ValueError("Could not add environment field to trace.")

		"""
		Add a clock to the trace. Clocks assigned to stream classes must be
		registered to the writer.
		"""
		def add_clock(self, clock):
			ret = _bt_ctf_writer_add_clock(self._w, clock._c)
			if ret < 0:
				raise ValueError("Could not add clock to Writer.")

		"""
		Get the trace's TSDL meta-data.
		"""
		@property
		def metadata(self):
			return _bt_ctf_writer_get_metadata_string(self._w)

		"""
		Flush the trace's metadata to the metadata file.
		"""
		def flush_metadata(self):
			_bt_ctf_writer_flush_metadata(self._w)

		"""
		Get the trace's byte order. Must be a constant from the ByteOrder
		class.
		"""
		@property
		def byte_order(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the trace's byte order. Must be a constant from the ByteOrder
		class. Defaults to BYTE_ORDER_NATIVE, the host machine's endianness.
		"""
		@byte_order.setter
		def byte_order(self, byte_order):
			ret = _bt_ctf_writer_set_byte_order(self._w, byte_order)
			if ret < 0:
				raise ValueError("Could not set trace's byte order.")


# This file is compatible with both classic and new-style classes.


